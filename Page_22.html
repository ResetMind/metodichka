<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>1. ТЕОРИЯ ТРАНСЛЯЦИИ</title>
		<link rel="stylesheet" type="text/css" href="css/style.css">
        <link rel="stylesheet" type="text/css" href="css/style22.css">
    </head>
    <body>
		<div id="wrapper">
			<div id="container">
				<p class="paragraph">
					Таким образом, последовательность четверок и является результатом работы синтаксического анализатора. 
				</p>
				<p class="header">
					1.3.2. Постфиксная запись 
				</p>
				<p class="paragraph">
					Обычно программа осуществляет те или иные действия над данными. Соответствующие операции
					программист записывает, используя инфиксную форму записи, в которой знак операции ставится между
					операндами. Например: 
				</p>
				<p class="expressions">
					(А + В) * С. 
				</p>
				<p class="paragraph">Вычисление такого выражения является непростой задачей. Операцию умножения нельзя выполнить до тех пор, пока не будет прочитан второй операнд С. Если этот операнд сам является сложным
				выражением, то прежде, чем выполнить умножение, необходимо считать много данных из текста программы.
				Отмеченные трудности можно легко обойти, если использовать другую форму записи операций.
				Она называется постфиксной и отличается тем, что знак операции ставится непосредственно за операндами. Такая запись обладает двумя ценными свойствами, благодаря которым ее используют как промежуточную форму представления исходной программы при трансляции:</p>
				<p class="paragraph">1. Для записи любого выражения не нужны скобки. Так как оператор непосредственно следует за
				операндами, участвующими в операции, неопределенность в указании операндов отсутствует. Например, выражение (А + В) * С в постфиксной записи имеет вид: А В + С *.</p>
				<p class="paragraph">2. К моменту считывания очередного оператора соответствующие операнды уже прочитаны. Поэтому оператор может быть выполнен без чтения каких-либо дополнительны данных.</p>
				<p class="paragraph">Сказанное выше относится к бинарным операциям, однако не трудно распространить результаты
				рассуждений и на унарные операции. Однако при этом могут возникнуть сложности. Например, знак "–
				" может стоять в инфиксной записи, указывая как бинарную, так и унарную операцию, и его правильный смысл становится очевидным из контекста. В постфиксной записи сделать это труднее. Унарный
				минус и другие унарные операции можно представлять двумя способами: либо записывать их как бинарные операции, например, вместо " – В " писать " 0 – В "; либо для обозначения унарных операций
				вводить новый символ, например, выражение А + (– В + С * Е) в постфиксной форме примет вид: А В
				@ С Е * + +</p> 
				<p class="header">
					1.4. ГЕНЕРАЦИЯ КОДА
				</p>
				<p class="paragraph">Возможны три формы объектного кода: абсолютные команды, помещенные в фиксированные ячейки (после окончания компиляции такая программа немедленно выполняется); программа на автокоде (ее
				потом придется транслировать); программа на языке машины, записанная на внешнюю память (для выполнения она должна быть объединена с другими подпрограммами и затем загружена).</p>
				<p class="paragraph">Первый вариант наиболее экономичен в отношении расходуемого времени. Главный недостаток
				этого варианта состоит в том, что нельзя предварительно и независимо протранслировать несколько
				подпрограмм и затем объединить их вместе дня выполнения, все подпрограммы должны транслироваться одновременно. Выигрыш во времени оборачивается проигрышем в гибкости.</p>
				<p class="paragraph">Проще всего получить объектную программу на автокоде. В этом случае не приходится формировать команды как последовательности битов; можно порождать команды, содержащие символические
				имена. Более того, можно формировать макроопределение. Это позволяет также уменьшить объем компилятора.</p>
				<p class="paragraph">Несмотря на очевидные достоинства, трансляция на автокод обычно считается наихудшим из вариантов. И в самом деле, к процессу трансляции добавляется еще один шаг, который часто требует столько же времени, сколько длится собственно компиляция.</p>
				<P class="paragraph">Большинство промышленных компиляторов вырабатывают объектную программу в виде объектного модуля. Как правило, объектный модуль содержит символические имена других программ (подпрограмм), к которым он обращается, и имена своих входных точек, к которым можно обращаться из других программ. Эта объектная программа "объединяется" с теми другими объектными программами, а
				затем загружается в некоторую область памяти для выполнения.</p>
			</div>
			<button id="next" onclick="location.href='Page_23.html'">Далее</button>
			<button id="back" onclick="location.href='Page_21.html'">Назад</button>
		</div>	
    </body>
</html>