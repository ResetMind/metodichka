<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>1. ТЕОРИЯ ТРАНСЛЯЦИИ</title>
		<link rel="stylesheet" type="text/css" href="css/style.css">
        <link rel="stylesheet" type="text/css" href="css/style24.css">
    </head>
    <body>
		<div id="wrapper">
			<div id="container">
				<p class="header">
					2. ОРГАНИЗАЦИЯ ТАБЛИЦ СИМВОЛОВ
				</p>
				<hr>
				<p class="paragraph">Проверка правильности семантики и генерация кода требуют знания характеристик идентификаторов, используемых в программе на исходном языке. Эти характеристики выясняются из описаний и из
				того, как идентификаторы используются в программе. Вся информация накапливается в таблицах символов.</p>
				<p class="paragraph">Таблицы всех типов имеют общий вид (табл. 6). В нашем случае аргументами таблицы являются
				символы или идентификаторы, а значениями – их характеристики. Когда компилятор начинает трансляцию исходной программы, таблица символов пуста или содержит только несколько элементов для служебных слов и стандартных функций.</p>
				<p class="paragraph">В процессе компиляции для каждого нового идентификатора элемент добавляется только один раз,
				но поиск ведется всякий раз, когда встречается этот идентификатор. Так как на этот процесс уходит
				много времени, важно выбрать такую организацию таблиц, которая допускала бы эффективный поиск.</p>  
				<table>
					<caption >Таблица 6</caption>
					   <tr>
						<th>№</th>
						<th>Аргумент</th>
						<th>Значение</th>
					   </tr>
					   <tr><td>1</td><td></td><td></td></tr>
					   <tr><td>2</td><td></td><td></td></tr>
					   <tr><td>...</td><td>...</td><td>...</td></tr>
					   <tr><td>...</td><td>...</td><td>...</td></tr>
					   <tr><td>...</td><td>...</td><td>...</td></tr>
					   <tr><td>N</td><td></td><td></td></tr>
				</table>
				<p class="header">
					2.1. УПОРЯДОЧЕННЫЕ И НЕУПОРЯДОЧЕННЫЕ ТАБЛИЦЫ
				</p>
				<p class="paragraph">Простейший способ организации таблицы состоит в том, чтобы добавлять элементы в порядке их
				поступления без каких-либо попыток упорядочения. Поиск в этом случае требует сравнения с каждым
				элементом таблицы, пока не будет найден подходящий. Для таблицы, содержащей N элементов, в среднем будет выполнено N/2 сравнений. Если N велико, такой способ неэффективен. Поиск может быть
				выполнен более эффективно, если элементы таблицы упорядочены согласно некоторому естественному
				порядку аргументов. В нашем случае, когда аргументами являются строки символов, наиболее естественным является упорядочение по алфавиту. Эффективным методом поиска в упорядоченном списке
				является так называемый бинарный поиск. Символ S, который следует найти, сравнивается с аргументом (n + 1)/2 в середине таблицы. Если этот элемент не является требуемым, мы должны просмотреть
				только блок элементов от (n + 1)/2 + 1 до n или от 1 до (n + 1)/2 – 1 в зависимости от того, больше элемент S или меньше элемента, с которым его сравнивали. Затем мы повторяем процесс над блоком
				меньшего размера.</p>
				<p class="paragraph">Так как на каждом шаге число элементов, которые могут содержать S, сокращается наполовину,
				максимальное число сравнений равно log2(n + 1). Если n = 2, нам потребуется самое большее 2 сравнения; если n = 4 – то 3; если n = 8 – то 4. Для n = 128 бинарный поиск требует самое большее 8 сравнений. В то время, как в неупорядоченной таблице в среднем потребуется 64 сравнения.</p>
				<p class="paragraph">Сортировка таблицы производится методом упорядоченных вставок.</p>
				<p class="header">
					2.2. ХЕШ-АДРЕСАЦИЯ
				</p>
				<img src="">
				<p class="paragraph">
					Наиболее эффективный и широко применяемый в компиляторах метод при работе с таблицами
					символов – хеш-адресация. Механизм расстановки состоит из таблицы и хеш-функции (табл. 7). Таб
				</p>
			</div>
			<button id="next" onclick="location.href='Page_23.html'">Назад</button>
		</div>	
    </body>
</html>