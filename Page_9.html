<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>1.2.1. Метод рекурсивного спуска</title>
		<link rel="stylesheet" type="text/css" href="css/style.css">
        <link rel="stylesheet" type="text/css" href="css/style9.css">
		<style>
		</style>
    </head>
    <body>
		<div id="wrapper">
			<div id="container">
				<p class="header">
					1.2.1. Метод рекурсивного спуска
				</p>
				<p class="paragraph">Процесс грамматического разбора для этого метода состоит из отдельных процедур для каждого
				нетерминального символа, определенного в грамматике. Каждая такая процедура старается во входном
				потоке найти подстроку, начинающуюся с текущей лексемы, которая может быть интерпретирована как
				нетерминальный символ, связанный с данной процедурой. В процессе своей работы она может вызывать другие процедуры или даже рекурсивно саму себя для поиска других нетерминальных символов.
				Если эта процедура находит соответствующий нетерминальный символ, то она заканчивает работу и
				передает в вызывающую ее программу признак успешного выполнения. Затем рассматривается следующая лексема, идущая за распознанной подстрокой. Если же процедура не может найти подстроку,
				которая могла бы быть интерпретирована как требуемый нетерминальный символ, она заканчивается с
				признаком неудачи или же вызывает процедуру диагностического сообщения.
				Рассмотрим в качестве примера правило грамматики:</p>
				<p class="expressions"><ввод> → read (<список переменных>)</p>
				<p class="paragraph">Процедура метода рекурсивного спуска, соответствующая нетерминальному символу <ввод>, прежде всего исследует две последовательные лексемы "read" и "(". В случае совпадения эта процедура вызывает другую процедуру, соответствующую нетерминальному символу <список переменных>. Если эта
				процедура закончится успешно, то процедура <ввод> сравнивает следующую лексему с ")". Если все
				эти проверки окажутся успешными, то процедура <ввод> завершается с признаком успеха и устанавливает указатель текущей лексемы на лексему, следующую за ")".
				Еще пример. Процедура, соответствующая нетерминальному символу <оператор>, анализирует
				очередную лексему для того, чтобы выбрать одну из четырех альтернатив:</p>
				<p class="expressions"><оператор> → <присваивание>/<ввод>/<вывод>/<цикл></p>
				<p class="paragraph">Если это лексема read, то вызывается процедура <ввод>. Если это лексема, соответствующая символу идентификатор, то вызывается процедура <присваивание>, поскольку это единственная альтернатива, которая может начинаться с лексемы идентификатор, и т.д.
				Но если мы попытаемся написать полный набор процедур для грамматики, то столкнемся со следующей трудностью – процедура для нетерминала <список переменных> будет не в состоянии выбрать
				одну из двух альтернатив, поскольку обе альтернативы: ид и <список переменных> могут начинаться с
				лексемы ид.</p>
				<p class="expressions"><список переменных> → ид/<список переменных>, ид</p>
				<p class="paragraph">Тут скрыта и более существенная трудность. Если процедура каким-либо образом решит попробовать альтернативу <список переменных>/ид, то она немедленно вызовет рекурсивно саму себя для поиска нетерминального символа <список переменных>. Это приведет еще к одному рекурсивному вызову и т.д., в результате чего образуется бесконечная цепочка рекурсивных вызовов. Те же проблемы возникнут и для некоторых других правил грамматики (<раздел переменных>, <раздел операторов>,
				<арифметическое выражение>, <слагаемое>). Как избежать такой рекурсии? Для этого применяют другую запись грамматики. Например:</p>
				<p class="expressions"><список переменных> → ид {, ид}</p>
				<p class="paragraph">Эта запись, являющаяся широко принятым расширением БНФ, означает, что конструкция, заключенная в фигурные скобки, может быть либо опущена, либо повторяться один или более число раз. Таким образом, это правило определяет нетерминальный символ <список переменных> как состоящий из
				единственной лексемы ид или же из произвольного числа следующих друг за другом лексем ид, разделенных запятой. Это, бесспорно, эквивалентно ранее принятому правилу. В соответствии с этим новым
				определением процедура <список переменных> сначала ищет лексему ид, а затем продолжает сканировать входной текст до тех пор, пока следующая пара лексем не совпадет с запятой и ид. Такая запись
				устраняет проблему рекурсии, а также решает вопрос выбора из двух альтернатив.</p>
				<p class="paragraph">Грамматика языка, к которому принадлежит предложение, представленное на рис. 1, имеет вид:</p>
			</div>
			<button id="next" onclick="location.href='Page_10.html'">Далее</button>
			<button id="back" onclick="location.href='Page_8.html'">Назад</button>
		</div>	
    </body>
</html>