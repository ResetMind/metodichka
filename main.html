<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Document</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <link rel="stylesheet" type="text/css" href="css/style5.css">
    <link rel="stylesheet" type="text/css" href="css/style6.css">
</head>

<body>
    <input type="checkbox" id="hmt" class="hidden_menu_ticker">
    <label class="btn_menu" for="hmt">
        <span class="first"></span>
        <span class="second"></span>
        <span class="third"></span>
    </label>
    <div class="hidden_menu">
        <ul>
            <li>ВВЕДЕНИЕ</li>
            <li>1. ТЕОРИЯ ТРАНСЛЯЦИИ</li>
            <ul>
                <li>1.1. Лексический анализ</li>
                <li>1.2. Синтаксический анализ</li>
                <ul>
                    <li>1.2.1. Метод рекурсивного спуска</li>
                    <li>1.2.2. Метод операторного предшествования</li>
                </ul>
                <li>1.3. Внутреннее представление программы</li>
                <ul>
                    <li>1.3.1. Последовательность четверок</li>
                    <li>1.3.2. Постфиксная запись</li>
                </ul>
                <li>1.4. Генерация кода</li>
            </ul>
            <li>2. ОРГАНИЗАЦИЯ ТАБЛИЦ СИМВОЛОВ</li>
            <ul>
                <li>2.1. Упорядоченные и неупорядоченные таблицы</li>
                <li>2.2. Хеш-адресация</li>
                <li>2.3. Рехеширование</li>
                <ul>
                    <li>2.3.1. Линейное рехеширование</li>
                    <li>2.3.2. Случайное рехеширование</li>
                    <li>2.3.3. Рехеширование сложением</li>
                </ul>
                <li>2.4. Метод цепочек</li>
            </ul>
            <li>3. ОПТИМИЗАЦИЯ КОДА</li>
            <li>КОНТРОЛЬНЫЕ ВОПРОСЫ И ЗАДАНИЯ</li>
            <li>КУРСОВАЯ РАБОТА ПО ДИСЦИПЛИНЕ "ЛИНГВИСТИЧЕСКОЕ И ПРОГРАММНОЕ ОБЕСПЕЧЕНИЕ САПР"</li>
            <li>ЗАКЛЮЧЕНИЕ</li>
            <li>СПИСОК ЛИТЕРАТУРЫ</li>
        </ul>
    </div>
    <!--p1-->
    <div class="wrapper">
        <div class="container">
            <p class="center">
                Министерство образования и науки Российской Федерации<br>
                ГОУ ВПО "Тамбовский государственный технический университет"
            </p>
            <p class="center bold" style="margin-top: 100px">
                И.Л. КОРОБОВА, И.А. ДЬЯКОВ, Ю.В. ЛИТОВКА
            </p>
            <p class="center bold" style="margin-top: 45px">
                ОСНОВЫ РАЗРАБОТКИ<br>
                ТРАНСЛЯТОРОВ В САПР
            </p>
            <p class="center" style="margin-top: 40px">
                Учебное пособие<br>
                по дисциплине "Лингвистическое и программное обеспечение САПР"<br>
                для студентов 2 курса дневного отделения<br>
                специальности 230104
            </p>
            <p class="center" style="margin-top: 145px">
                <img class="logo" src="image/logo.jpg">
            </p>
            <hr class="band">
            <p class="center bold" style="margin-top: 10px">
                ТАМБОВ<br>
                ИЗДАТЕЛЬСТВО Тгту<br>
                2007
            </p>
        </div>
    </div>
    <!--p2-->
    <div class="wrapper">
        <div class="container">
            <p>
                УДК (681:004.4'42)(075)<br>
                ББК &larr;973-018-5-05я73<br>
                К68
            </p>
            <p class="center font_9" style="margin-top: 35px">
                Рецензенты:<br>
                Кандидат технических наук, доцент кафедры АПТО ТГТУ
            </p>
            <p class="center font_9 bold">М.Н. Краснянский</p>
            <p class="center font_9" style="margin-top: 15px">
                Кандидат технических наук, доцент кафедры<br>
                компьютерного и математического моделирования<br>
                ТГУ им. Г.Р. Державина<br>
                <span class="center bold">В.П. Дудаков</span>
            </p>
            <p class="bold font_9" style="text-indent: 35px; margin-top: 75px">Коробова, И.Л.</p>
            <p class="font_10 justify">
                К68 Основы разработки трансляторов в САПР : учебное пособие / И.Л. Коробова, И.А. Дьяков, Ю.В.
                Литовка. – Тамбов : Изд-во Тамб. гос. техн. ун-та, 2007. – 80 с. – 100 экз. – ISBN 5-8265-0591-5 (978-5-
                8265-0591-5).
            </p>
            <p class="font_7 justify" style="text-indent: 20px; margin-top: 25px;">
                Рассматриваются общие сведения по структуре и составу трансляторов, даны рекомендации по разработке
                транслирующих программ, рассматриваются различные методы синтаксического анализа и генерации кода,
                приведены вопросы для самостоятельного изучения.
            </p>
            <p class="font_7 justify" style="text-indent: 20px">
                Предназначено для студентов 2 курса дневного отделения специальности 230104.
            </p>
            <p class="center font_9" style="margin-top: 12px">
                УДК (681:004.4'42)(075)<br>
                ББК &larr;973-018-5-05я73
            </p>
            <p class="font_9" style="margin-top: 30px">
                ISBN 5-8265-0591-5<br>
                (978-5-8265-
            </p>
            <p class="center font_9" style="margin-top: -20px">
                ГОУ ВПО "Тамбовский государственный<br>
                технический университет" (ТГТУ), 2007
            </p>
        </div>
    </div>
    <!--p3-->
    <div class="wrapper">
        <div class="container">
            <p class="center" style="margin-top: 110px">
                Учебное издание
            </p>
            <p class="center" style="margin-top: 10px">
                КОРОБОВА Ирина Львовна,
                ДЬЯКОВ Игорь Алексеевич,
                ЛИТОВКА Юрий Владимирович
            </p>
            <p class="center" style="margin-top: 15px">
                ОСНОВЫ РАЗРАБОТКИ
                ТРАНСЛЯТОРОВ В САПР
            </p>
            <p class="center" style="margin-top: 12px">
                Учебное пособие
            </p>
            <p class="center" style="margin-top: 20px">
                Редактор О.М. Ярцева<br>
                Инженер по компьютерному макетированию Е.В. Кораблева
            </p>
            <p class="center font_7" style="margin-top: 25px">
                Подписано в печать 18.04.2007<br>
                Формат 60 × 84/16. 4,65 усл. печ. л. Тираж 100 экз. Заказ № 294
            </p>
            <p class="center font_7" style="margin-top: 10px">
                Издательско-полиграфический центр<br>
                Тамбовского государственного технического университета<br>
                392000, Тамбов, Советская, 106, к. 14
            </p>
        </div>
    </div>
    <!--p4-->
    <div class="wrapper">
        <div class="container">
            <h1>
                ВВЕДЕНИЕ
            </h1>
            <hr>
            <p class="paragraph">
            <p class="paragraph">В состав любой вычислительной системы может входить комплекс программ, которые
                называются трансляторами. Транслятор обеспечивает автоматический перевод программ с алгоритмического
                языка в машинные коды.</p>
            <p class="paragraph">По функциональному назначению трансляторы делятся на компиляторы (перевод программ на
                языке высокого уровня в машинные коды без выполнения), интерпретаторы (перевод каждой конструкции
                алгоритмического языка в машинные коды с одновременным выполнением) и ассемблеры
                (перевод программы с языка низкого уровня в машинные коды).</p>
            <p class="paragraph">Более подробно остановимся на компиляторах. Компилятор – это не что иное, как
                программа,
                написанная на некотором языке, для которой входной информацией служит исходная программа, а
                результатом является эквивалентная ей объектная программа. Раньше компиляторы писались на автокоде.
                Часто это был единственно доступный язык. Однако сейчас существует тенденция писать
                компиляторы на языках высокого уровня, поскольку при этом уменьшается время, затрачиваемое
                на программирование и отладку, а также обеспечивается удобочитаемость компилятора, когда работа над ним
                завершена.</p>
            <p class="paragraph">Компиляторам присущ ряд общих черт, что упрощает процесс создания компилирующих
                программ. Наша цель состоит в том, чтобы описать известные уже модельные представления структуры
                компиляторов и показать, как с их помощью создается работоспособная компилирующая программа.</p>
            <p class="paragraph">Компилятор должен выполнить анализ исходной программы и синтез объектного кода. В
                соответствии с этим любой компилятор включает три основные части: лексический анализатор, синтаксический
                анализатор и генератор кода.</p>
            <p class="paragraph">Взаимодействие между компонентами компилятора может осуществляться разнообразными
                способами.</p>
            <p class="paragraph">В настоящей работе рассматриваются основные подходы к созданию транслирующих программ.
                Приведенные подходы будут полезны для студентов 2-го курса специальности 230104 – "САПР" при
                выполнении лабораторных и курсовой работы по дисциплине "Лингвистическое и программное
                обеспечение САПР"</p>
            </p>
        </div>
    </div>
    <!--p5-->
    <div class="wrapper">
        <div class="container">
            <h1>
                1. ТЕОРИЯ ТРАНСЛЯЦИИ
            </h1>
            <hr>
            <h2>
                1.1. ЛЕКСИЧЕСКИЙ АНАЛИЗ
            </h2>
            <p class='paragraph'>
            <p class="paragraph">На вход компилятора, а следовательно, и лексического анализатора поступает цепочка
                символов
                некоторого алфавита. Работа лексического анализатора заключается в том, чтобы сгруппировать определенные
                символы в единые синтаксические объекты, называемые лексемами. Какие объекты считать лексемами, зависит
                от определения языка. Кроме терминальных символов (+, –, /, *, (,)), которые
                сами по себе являются лексемами, в программе некоторые комбинации символов часто рассматриваются как
                единые объекты. Среди типичных примеров можно указать следующие.</p>
            <li>В некоторых языках цепочка, состоящая из одного или более пробелов, обычно рассматривается как один
                пробел.</li>
            <li>В языках программирования есть ключевые слова, такие, как begin, еnd, to, do, integer и другие,
                каждое из которых считается одним символом.</li>
            <li>Каждая цепочка, представляющая цифровую константу, рассматривается как один элемент текста.</li>
            <li>Идентификаторы, используемые имена переменных, функций, процедур, меток и т.п., также считаются
                лексическими единицами алгоритмического языка.</li>
            <p class="paragraph">Для программы на рис. 1 будем считать лексемами терминальные символы, относящиеся к
                ключевым словам, знакам операций, разделителям (рrоgram, vаr, begin, integer, end, (,), :=, +, –, *,
                div, rеad, for,
                write, tо, do, :, ; , .). Кроме того, возможны лексемы – идентификаторы и константы.</p>
            </p>
            <div id='code_5'>
                <p class="font_10 left">
                    program primer;<br>
                    var sum, a, rez, i: integer;<br>
                    begin<br>
                    sum:=0;<br>
                    for i:=1 to 100 do begin<br>
                    read(a);<br>
                    sum:=sum+a<br>
                    end;<br>
                    rez:=sum div100–a*a;<br>
                    write(rez,sum)<br>
                    end.<br>
                </p>
            </div>
            <p class='picture_number'>
                Рис.1
            </p>
            <p class="paragraph">Итак, лексический анализатор должен исходный текст программы (рис. 1) представить в
                виде последовательности лексем. Для эффективности последующих действий каждая лексема обычно
                представляется некоторым кодом фиксированной длины (например, целым числом), а не в виде строки символов
                переменной длины.</p>
            <p class="paragraph">Для вышеприведенного примера можно составить кодировочную таблицу (табл. 1). Если
                распознанная лексема является ключевым словом, разделителем или знаком операции, такая схема кодирования
                дает всю необходимую информацию.</p>
            <p class="paragraph">В случае идентификатора или константы необходимы дополнительные данные (в простейшем
                случае – тип и указание на адрес ячейки памяти, где они хранятся). Обычно эти данные находятся в
                таблицах символов, и в качестве дополнительной информации для лексемы типа идентификатор или константа
                может служить указатель на соответствующий элемент таблицы.</p>
        </div>
    </div>
    <!--p6-->
    <div class="wrapper">
        <div class="container">
            <table id="table_6_1">
                <caption>Таблица 1</caption>
                <tr>
                    <th>Лексема</th>
                    <th>Код</th>
                </tr>
                <tr>
                    <td>program</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td>var</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td>begin</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>end</td>
                    <td>4</td>
                </tr>
                <tr>
                    <td>integer</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td>for</td>
                    <td>6</td>
                </tr>
                <tr>
                    <td>read</td>
                    <td>7</td>
                </tr>
                <tr>
                    <td>write</td>
                    <td>8</td>
                </tr>
                <tr>
                    <td>to</td>
                    <td>9</td>
                </tr>
                <tr>
                    <td>do</td>
                    <td>10</td>
                </tr>
                <tr>
                    <td>.</td>
                    <td>11</td>
                </tr>
                <tr>
                    <td>;</td>
                    <td>12</td>
                </tr>
                <tr>
                    <td>:</td>
                    <td>13</td>
                </tr>
                <tr>
                    <td>,</td>
                    <td>14</td>
                </tr>
                <tr>
                    <td>:=</td>
                    <td>15</td>
                </tr>
                <tr>
                    <td>+</td>
                    <td>16</td>
                </tr>
                <tr>
                    <td>-</td>
                    <td>17</td>
                </tr>
                <tr>
                    <td>*</td>
                    <td>18</td>
                </tr>
                <tr>
                    <td>div</td>
                    <td>19</td>
                </tr>
                <tr>
                    <td>(</td>
                    <td>20</td>
                </tr>
                <tr>
                    <td>)</td>
                    <td>21</td>
                </tr>
                <tr>
                    <td>ид</td>
                    <td>22</td>
                </tr>
                <tr>
                    <td>конст</td>
                    <td>23</td>
                </tr>
            </table>
            <p class="paragraph">
                Таким образом, результат обработки лексическим анализатором обрабатываемой программы можно
                представить последовательностью лексем (табл. 2). Здесь в качестве дополнительных данных для констант
                используется значение самой константы, а для идентификатора – его номер в таблице символов.
            </p>
            <table>
                <caption>Таблица 2</caption>
                <tr>
                    <th>Строка</th>
                    <th>Код лексемы</th>
                    <th>Дополнительные данные</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>1</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>1</td>
                </tr>
                <tr>
                    <td></td>
                    <td>12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>2</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td></td>
                    <td>14</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td></td>
                    <td>14</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>4</td>
                </tr>
            </table>
        </div>
    </div>
    <!--p7-->
    <div class="wrapper">
        <div class="container">
            <table>
                <tr>
                    <td></td>
                    <td>14</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td></td>
                    <td>13</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>5</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>3</td>
                    <td></td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>22</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td></td>
                    <td>15</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>6</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>5</td>
                </tr>
                <tr>
                    <td></td>
                    <td>15</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>23</td>
                    <td>#1</td>
                </tr>
                <tr>
                    <td></td>
                    <td>9</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>23</td>
                    <td>#100</td>
                </tr>
                <tr>
                    <td></td>
                    <td>10</td>
                    <td></td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>3</td>
                    <td></td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>7</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>20</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td></td>
                    <td>21</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>8</td>
                    <td>22</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td></td>
                    <td>15</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td></td>
                    <td>16</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td>4</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>10</td>
                    <td>22</td>
                    <td>4</td>
                </tr>
                <tr>
                    <td></td>
                    <td>15</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td></td>
                    <td>19</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>23</td>
                    <td>#100</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>2</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>3</td>
                </tr>
                <tr>
                    <td></td>
                    <td>18</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>3</td>
                </tr>
            </table>
        </div>
    </div>
    <!--p8-->
    <div class="wrapper">
        <div class="container">
            <table>
                <tr>
                    <td></td>
                    <td>12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>11</td>
                    <td>8</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>20</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>4</td>
                </tr>
                <tr>
                    <td></td>
                    <td>14</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>22</td>
                    <td>2</td>
                </tr>
                <tr>
                    <td></td>
                    <td>21</td>
                    <td></td>
                </tr>
                <tr>
                    <td>12</td>
                    <td>4</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td>11</td>
                    <td></td>
                </tr>
            </table>
            <h2>
                1.2. СИНТАКСИЧЕСКИЙ АНАЛИЗ
            </h2>
            <p class="paragraph">
                Синтаксический анализ – второй этап компиляции. Во время этого этапа предложения программы
                распознаются как языковые конструкции используемой грамматики. Для того чтобы выяснить, принадлежит ли
                предложение языку, необходимо построить алгоритм, который для любого предложения, допустимого
                грамматикой, давал бы последовательность выводов этой цепочки к начальному символу
                грамматики. Мы можем рассматривать этот процесс как построение дерева грамматического разбора
                для транслируемых предложений. Различают две категории алгоритмов разбора: нисходящий (сверху
                вниз) и восходящий (снизу вверх). Эти термины соответствуют способу построения синтаксических деревьев.
                Рассмотрим для примера предложение 35 в грамматике целых чисел:
            </p>
            <p class="expressions">
                N&rarr;В/NВ; В&rarr;0/1/2/3/4/5/6/7/8/9.
            </p>
            <p class="paragraph">
                При нисходящем разборе дерево строится от корня (начального символа) вниз к концевым узлам
                (рис. 2)
            </p>
            <!--<img id="image1" src="image/image1_page_8.jpg">-->
            <p class="expressions">N&rarr;NB&rarr;N5&rarr;B5&rarr;35</p>
            <p class="expressions">
                N<br>
                <span style="transform: rotate(45deg);">&darr;</span><span
                    style="transform: rotate(-45deg);">&darr;</span><br>
                N&ensp;B<br>
                &darr;&ensp;&darr;<br>
                B&ensp;5<br>
                &darr;&ensp;&ensp;<br>
                3&ensp;&ensp;

            </p>
            <p class='picture_number'>Рис.2</p>
            <p class="paragraph">
                Восходящий разбор состоит в том, что, отправляясь от заданной цепочки, пытаются привести ее к
                начальному символу (рис. 3).
            </p>
            <!--<img id="image2" src="image/image2_page_8.jpg">-->
            <p class="expressions">35&rarr;B5&rarr;N5&rarr;NB&rarr;N</p>
            <p class="expressions">
                N<br>
                <span style="transform: rotate(45deg);">&uarr;</span><span
                    style="transform: rotate(-45deg);">&uarr;</span><br>
                N&ensp;B<br>
                &uarr;&ensp;&uarr;<br>
                B&ensp;5<br>
                &uarr;&ensp;&ensp;<br>
                3&ensp;&ensp;

            </p>
            <p class='picture_number'>Рис.3</p>
            <p class="paragraph">
                Разработано множество методов синтаксического анализа. В лабораторных работах рассматриваются два
                метода: нисходящий и восходящий.
            </p>
        </div>
    </div>
    <!--p9-->
    <div class="wrapper">
        <div class="container">
            <h3>
                1.2.1. Метод рекурсивного спуска
            </h3>
            <p class="paragraph">Процесс грамматического разбора для этого метода состоит из отдельных процедур для
                каждого
                нетерминального символа, определенного в грамматике. Каждая такая процедура старается во входном
                потоке найти подстроку, начинающуюся с текущей лексемы, которая может быть интерпретирована как
                нетерминальный символ, связанный с данной процедурой. В процессе своей работы она может вызывать другие
                процедуры или даже рекурсивно саму себя для поиска других нетерминальных символов.
                Если эта процедура находит соответствующий нетерминальный символ, то она заканчивает работу и
                передает в вызывающую ее программу признак успешного выполнения. Затем рассматривается следующая
                лексема, идущая за распознанной подстрокой. Если же процедура не может найти подстроку,
                которая могла бы быть интерпретирована как требуемый нетерминальный символ, она заканчивается с
                признаком неудачи или же вызывает процедуру диагностического сообщения.
                Рассмотрим в качестве примера правило грамматики:</p>
            <p class="expressions">
                <ввод> → read (<список переменных>)
            </p>
            <p class="paragraph">Процедура метода рекурсивного спуска, соответствующая нетерминальному символу <ввод>,
                    прежде всего исследует две последовательные лексемы "read" и "(". В случае совпадения эта процедура
                    вызывает другую процедуру, соответствующую нетерминальному символу <список переменных>. Если эта
                        процедура закончится успешно, то процедура <ввод> сравнивает следующую лексему с ")". Если все
                            эти проверки окажутся успешными, то процедура <ввод> завершается с признаком успеха и
                                устанавливает указатель текущей лексемы на лексему, следующую за ")".
                                Еще пример. Процедура, соответствующая нетерминальному символу <оператор>, анализирует
                                    очередную лексему для того, чтобы выбрать одну из четырех альтернатив:</p>
            <p class="expressions">
                <оператор> → <присваивание>/<ввод>/<вывод>/<цикл>
            </p>
            <p class="paragraph">Если это лексема read, то вызывается процедура <ввод>. Если это лексема,
                    соответствующая символу идентификатор, то вызывается процедура <присваивание>, поскольку это
                        единственная альтернатива, которая может начинаться с лексемы идентификатор, и т.д.
                        Но если мы попытаемся написать полный набор процедур для грамматики, то столкнемся со следующей
                        трудностью – процедура для нетерминала <список переменных> будет не в состоянии выбрать
                            одну из двух альтернатив, поскольку обе альтернативы: ид и <список переменных> могут
                                начинаться с
                                лексемы ид.</p>
            <p class="expressions">
                <список переменных> → ид/<список переменных>, ид
            </p>
            <p class="paragraph">Тут скрыта и более существенная трудность. Если процедура каким-либо образом решит
                попробовать альтернативу <список переменных>/ид, то она немедленно вызовет рекурсивно саму себя для
                    поиска нетерминального символа <список переменных>. Это приведет еще к одному рекурсивному вызову и
                        т.д., в результате чего образуется бесконечная цепочка рекурсивных вызовов. Те же проблемы
                        возникнут и для некоторых других правил грамматики (<раздел переменных>, <раздел операторов>,
                                <арифметическое выражение>, <слагаемое>). Как избежать такой рекурсии? Для этого
                                        применяют другую запись грамматики. Например:</p>
            <p class="expressions">
                <список переменных> → ид {, ид}
            </p>
            <p class="paragraph">Эта запись, являющаяся широко принятым расширением БНФ, означает, что конструкция,
                заключенная в фигурные скобки, может быть либо опущена, либо повторяться один или более число раз. Таким
                образом, это правило определяет нетерминальный символ <список переменных> как состоящий из
                    единственной лексемы ид или же из произвольного числа следующих друг за другом лексем ид,
                    разделенных запятой. Это, бесспорно, эквивалентно ранее принятому правилу. В соответствии с этим
                    новым
                    определением процедура <список переменных> сначала ищет лексему ид, а затем продолжает сканировать
                        входной текст до тех пор, пока следующая пара лексем не совпадет с запятой и ид. Такая запись
                        устраняет проблему рекурсии, а также решает вопрос выбора из двух альтернатив.</p>
            <p class="paragraph">Грамматика языка, к которому принадлежит предложение, представленное на рис. 1, имеет
                вид:</p>
        </div>
    </div>
    <!--p10-->
    <div class="wrapper">
        <div class="container">
            <p class="code">
                <программа> → <имя программы> var <раздел<br>
                            переменных> begin <раздел операторов> end.<br>
                                <имя программы> → ид<br>
                                    <раздел переменных> → <список переменных>:<тип><br>
                                                <список переменных> → ид {, ид}<br>
                                                    <тип> → integer<br>
                                                        <оператор> → <присваивание> / <ввод> /<вывод> /<цикл><br>
                                                                            <присваивание> → ид := <арифметическое
                                                                                    выражение><br>
                                                                                    <арифметическое выражение> →
                                                                                        <слагаемое> {+<слагаемое>}{–
                                                                                                <слагаемое>}<br>
                                                                                                    <слагаемое> →
                                                                                                        <значение> {*
                                                                                                            <значение>}
                                                                                                                {div
                                                                                                                <значение>
                                                                                                                    }<br>
                                                                                                                    <ввод>
                                                                                                                        →
                                                                                                                        read
                                                                                                                        (
                                                                                                                        <список
                                                                                                                            переменных>
                                                                                                                            )<br>
                                                                                                                            <вывод>
                                                                                                                                →
                                                                                                                                write
                                                                                                                                (
                                                                                                                                <список
                                                                                                                                    переменных>
                                                                                                                                    )<br>
                                                                                                                                    <цикл>
                                                                                                                                        →
                                                                                                                                        for
                                                                                                                                        <выражение
                                                                                                                                            цикла>
                                                                                                                                            to
                                                                                                                                            <тело
                                                                                                                                                цикла>
                                                                                                                                                <br>
                                                                                                                                                <выражение
                                                                                                                                                    цикла>
                                                                                                                                                    →
                                                                                                                                                    ид
                                                                                                                                                    :=
                                                                                                                                                    <арифметическое
                                                                                                                                                        выражение>
                                                                                                                                                        <br>
                                                                                                                                                        do
                                                                                                                                                        <арифметическое
                                                                                                                                                            выражение>
                                                                                                                                                            <br>
                                                                                                                                                            <тело
                                                                                                                                                                цикла>
                                                                                                                                                                →
                                                                                                                                                                <оператор>
                                                                                                                                                                    /
                                                                                                                                                                    begin
                                                                                                                                                                    <раздел
                                                                                                                                                                        операторов>
                                                                                                                                                                        end<br>
            </p>
            <p class="paragraph">Приведем примеры алгоритмов синтаксического анализа методом рекурсивного спуска для
                некоторых предложений исходной программы с использованием приведенной грамматики.</p>
            <p class="paragraph">Имеем предложение исходной программы: read (a).</p>
            <p class="paragraph">Тогда процедура разбора этого предложения может иметь вид</p>
            <p class="code">
                procedure <ввод>;<br>
                    begin<br>
                    BP := false;<br>
                    &nbsp;if t = read then<br>
                    &nbsp;&nbsp;begin<br>
                    &nbsp;&nbsp;&nbsp;перейти к следующей лексеме;<br>
                    &nbsp;&nbsp;&nbsp;if t = ( then begin<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;перейти к следующей лексеме;<br>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if <список переменных> закончилась успешно<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;then<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if t = ) then begin<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BP := true;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;перейти к следующей лексеме;<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end; {if )}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end; {if (}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end; {if read}<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if BP = true then успешное завершение<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else неудачное завершение;<br>
                        end; <br>
            </p>
            <p class="paragraph">
                В приведенной процедуре BP – вспомогательная переменная, а t – переменная, определяющая тип
                лексемы. Процедура, соответствующая нетерминальному символу <ввод>, вызывает процедуру <список
                        переменных>:
            </p>
            <p class="code">
                procedure <список переменных>;<br>
                    begin<br>
                    BP := false;<br>
                    if t=ид then<br>
                    begin <br>
            </p>
        </div>
    </div>
    <!--p11-->
    <div class="wrapper">
        <div class="container">
            <p class="code">
                BP := true;<br>
                перейти к следующей лексеме;<br>
                while ( t = , ) and ( BP = true ) do<br>
                begin<br>
                перейти к следующей лексеме;<br>
                if t = ид then перейти к следующей<br>
                лексеме<br>
                else BP := false;<br>
                end; {while}<br>
                if BP = true then успешное завершение<br>
                else неудачное завершение;<br>
                end;<br>
            </p>
            <p class="paragraph">
                На рис. 4 графически представлен процесс грамматического разбора методом рекурсивного спуска
                для предложения read. На фрагменте а) изображен вызов процедуры <ввод>, которая обнаружила лексемы read
                    и ) во входном потоке (штриховая линия). На фрагменте б) процедура <ввод> вызывает процедуру <список
                            переменных> (сплошная линия), которая обработала лексему ид. На фрагменте в) процедура
                            <список переменных> закончила работу, передала управление процедуре <ввод> с признаком
                                    успешного завершения; процедура <ввод> обработала входную лексему ). На этом анализ
                                        входного
                                        предложения завершен.
            </p>
            <img id="image1" src="image/image1_page_11.jpg">
            <!--<div><div style="border: 1px solid black; width: 60px; height: 20px; text-align: center;">Ввод</div>&ensp;<span style = "transform: rotate(45deg);">&brvbar;</span>&ensp;&ensp;&ensp;&brvbar;<br>read&ensp;)</div>-->
            <p class="paragraph">
                Приведем еще один пример. Имеем предложение из исходной программы:
            </p>
            <p class="code">REZ := SUM DIV 100 – A * A</p>
            <p class="paragraph">
                Представим алгоритмы разбора этого предложения методом рекурсивного спуска:
            </p>
            <p class="code">
                procedure <присваивание><br>
                    begin<br>
                    BP := false;<br>
                    if t = ид then<br>
                    begin<br>
                    перейти к следующей лексеме;<br>
                    if t = := then<br>
                    begin<br>
                    перейти к следующей лексеме;<br>
                    if <арифметическое выражение><br>
                        завершилось успешно then <br>
            </p>
        </div>
    </div>
    <!--p12-->
    <div class="wrapper">
        <div class="container">
            <p class="code">
                BP := true;<br>
                end; {if :=}<br>
                end; {if ид.}<br>
                if BP = true then успешное завершение<br>
                else неудачное завершение;<br>
                end;<br>
            </p>
            <p class="paragraph">
                Процедура присваивание в процессе работы вызывает процедуру <арифметическое выражение>:
            </p>
            <p class="code">
                procedure <арифметическое выражение>;<br>
                    begin<br>
                    BP:=false;<br>
                    if <слагаемое> завершилось успешно then<br>
                        begin<br>
                        BP:=true;<br>
                        while (t = + или t = – ) and ( BP=true ) do<br>
                        begin<br>
                        Перейти к следующей лексеме;<br>
                        if <слагаемое> завершилось неудачно<br>
                            then<br>
                            BP:=false;<br>
                            end; {while}<br>
                            end; {if слагаемое}<br>
                            if BP = true then успешное завершение<br>
                            else неудачное завершение;<br>
                            end;
            </p>
            <p class="paragraph">
                Процедура <арифметическое выражение>, в соответствии с грамматикой, вызывает процедуру
                    <слагаемое>:
            </p>
            <p class="code">
                procedure <слагаемое> ;<br>
                    begin<br>
                    BP:=false;<br>
                    if <значение> завершилось успешно then<br>
                        begin<br>
                        BP:=true;<br>
                        while (t = * или t = div ) and ( BP=true ) do<br>
                        begin<br>
                        Перейти к следующей лексеме;<br>
                        if <значение> завершилось неудачно<br>
                            then<br>
                            BP:=false;<br>
                            end; {while}<br>
                            end; {if значение}<br>
                            if BP=true then успешное завершение<br>
                            else неудачное завершение;<br>
                            end;
            </p>
            <p class="paragraph">
                И наконец, процедура <слагаемое> вызывает процедуру <значение>, которая распознает переменные, константы
                        или вызывает процедуру <арифметическое выражение>. Алгоритм процедуры <значение> имеет вид:
            </p>
        </div>
    </div>
    <!--p13-->
    <div class="wrapper">
        <div class="container">
            <p class="code">
                procedure значение;<br>
                begin<br>
                BP:=false;<br>
                if t = ид или t = конст then<br>
                begin<br>
                BP:=true;<br>
                Перейти к следующей лексеме;<br>
                end {if ид или конст}<br>
                else<br>
                if t = ( then begin<br>
                Перейти к следующей лексеме;<br>
                if <арифметическое выражение> завершилось успешно then<br>
                    if t = ) then<br>
                    begin<br>
                    BP:=true;<br>
                    Перейти к следующей лексеме;<br>
                    end; {if )}<br>
                    end; {if (}<br>
                    if BP = true then успешное завершение<br>
                    else неудачное завершение;<br>
                    end;
            </p>
            <p class="paragraph">Графически разбор этого предложения методом рекурсивного спуска выглядит так:</p>
            <p class="paragraph">1. Вызывается процедура <присваивание>, которая обнаружила лексемы ид и := во входном
                    потоке (рис. 5, а).</p>
            <p class="paragraph">2. Процедура < присваивание> вызывает процедуру <арифметическое выражение> (рис. 5, б)
            </p>
            <p class="paragraph">3. Процедура <арифметическое выражение> вызывает процедуру <слагаемое> (рис. 6, а).</p>
            <p class="paragraph">4. Процедура <слагаемое>. вызывает процедуру <значение>, которая обнаруживает лексему
                        ид.
                        Управление возвращается в процедуру <слагаемое> (рис. 6, б).</p>
            <p class="paragraph">5. Процедура <слагаемое> обнаруживает лексему div и вызывает процедуру <значение>,
                        которая
                        обнаруживает лексему конст. и передает управление в процедуру <арифметическое выражение> (рис.
                            7, a).</p>
            <img id="image1" src="image/image1_page_13.jpg">
        </div>
    </div>
    <!--p14-->
    <div class="wrapper">
        <div class="container">
            <img id="image1" src="image/image1_page_14.jpg">
            <p class="paragraph">6. Процедура <арифметическое выражение> распознает лексему –, затем вызывает процедуру
                    <слагаемое>, которая вызывает процедуру <значение>, которая распознает лексему ид и передает
                            управление в процедуру <слагаемое> (рис. 7, б).</p>
            <p class="paragraph">7. Процедура <слагаемое> распознает лексему *, затем вызывает процедуру <значение>,
                        которая
                        распознает лексему ид. Следующая лексема читается в процедуре <значение>. Эта лексема не
                            относится к данному предложению. Управление передается в процедуру <слагаемое>, которая
                                формирует признак успешного завершения и передает управление в процедуру <арифметическое
                                    выражение>. Эта
                                    процедура, в свою очередь, успешно заканчивается и передает управление в процедуру
                                    <присваивание>, которая формирует признак успешного завершения. На этом разбор этого
                                        предложения заканчивается (рис. 8).</p>
            <img id="image2" src="image/image2_page_14.jpg">
        </div>
    </div>
    <!--p15-->
    <div class="wrapper">
        <div class="container">
            <img id="image1" src="image/image1_page_15.jpg">
            <img id="image2" src="image/image2_page_15.jpg">
            <p class="paragraph">
                Мы привели примеры грамматического разбора отдельных предложений методом рекурсивного
                спуска. Однако этот метод применим и ко всей программе в целом. В этом случае для осуществления
                синтаксического анализа следует просто обратиться к процедуре, соответствующей нетерминальному
                символу <программа>. В результате работы этой процедуры будет построено дерево грамматического
                    разбора для всей программы.
            </p>
            <h3>
                1.2.2. Метод операторного предшествования
            </h3>
            <p class="paragraph">
                Этот метод относится к восходящим (метод снизу вверх), которые начинают разбор с конечных узлов
                грамматического дерева и пытаются объединить их построением узлов все более и более высокого
                уровня до тех пор, пока не будет достигнут корень дерева. Метод операторного предшествования основан на
                анализе пар последовательно расположенных операторов исходной программы и решением вопроса о том, какой
                из них должен выполняться первым. Рассмотрим, например, арифметическое выражение
            </p>
            <p class="expressions">
                А + В * С – В.
            </p>
        </div>
    </div>
    <!--p16-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">
                В соответствии с обычными правилами арифметики умножение и деление осуществляются до сложения и
                вычитания. Можно сказать, что умножение и деление имеют более высокий уровень предшествования, чем
                сложение и вычитание. При анализе первых двух операторов (+, *) выяснится, что оператор + имеет более
                низкий уровень предшествования, чем оператор *. Часто это записывают следующим
                образом
            </p>
            <p class="expressions">+ <• *</p>
                    <p class="paragraph">
                        Аналогично для следующей пары операторов (* и –) оператор * имеет более высокий уровень
                        предшествования, чем оператор –. Мы можем записать это в виде
                    </p>
                    <p class="expressions">*•>–</p>
                    <p class="paragraph">
                        Метод операторного предшествования использует подобные отношения между операторами для
                        управления процессом грамматического разбора. В частности, для рассмотренного арифметического
                        выражения мы получили следующие отношения предшествования:
                    </p>
                    <p id="expressions">А + В * С – В<br>
                        <• •>
                    </p>
                    <p class="paragraph">Отсюда следует, что подвыражение В * С должно быть вычислено до обработки любых
                        других операторов рассматриваемого выражения. В терминах дерева грамматического разбора это
                        означает, что
                        операция * расположена на более низком уровне узлов дерева, чем операция + или –. Таким образом,
                        рассматриваемый метод грамматического разбора должен распознать конструкцию В * С, интерпретируя
                        ее в терминах заданной грамматики, до анализа соседних термов предложения.</p>
                    <p class="paragraph">Предшествующее изложение иллюстрирует основную идею, на которой основан метод
                        грамматического разбора, построенный на отношения операторного предшествования. В рамках этого
                        метода
                        предложение сканируется слева направо до тех пор, пока не будет найдено подвыражение, операторы
                        которого имеют более высокий уровень предшествования, чем соседние операторы. Далее это
                        подвыражение распознается в терминах правил вывода используемой грамматики. Этот процесс
                        продолжается до тех пор, пока не достигнут корень дерева, что и будет означать окончание
                        процесса грамматического разбора. Далее мы рассмотрим приложение описанного подхода к нашему
                        примеру программы
                        (рис. 1). Грамматика этого предложения имеет вид:</p>
                    <p class="code">
                        <программа>→<имя программы> vаr <раздел переменных> begin <раздел операторов> end.<br>
                                        <имя программы>→ид<br>
                                            <раздел переменных>→<список переменных>:<тип><br>
                                                        <список переменных>→ид / <список переменных>, ид<br>
                                                                <тип>→integer<br>
                                                                    <раздел операторов>→<оператор>/<раздел операторов>;
                                                                                <оператор><br>
                                                                                    <оператор>→<присваивание>/<ввод>/
                                                                                                <вывод>/<цикл><br>
                                                                                                        <присваивание>
                                                                                                            →ид :=
                                                                                                            <арифметическое
                                                                                                                выражение>
                                                                                                                <br>
                                                                                                                <арифметическое
                                                                                                                    выражение>
                                                                                                                    →
                                                                                                                    <слагаемое>
                                                                                                                        /
                                                                                                                        <арифметическое
                                                                                                                            выражение>
                                                                                                                            +/–
                                                                                                                            <слагаемое>
                                                                                                                                <br>
                                                                                                                                <слагаемое>
                                                                                                                                    →
                                                                                                                                    <значение>
                                                                                                                                        >/
                                                                                                                                        <слагаемое>
                                                                                                                                            */div
                                                                                                                                            <значение>
                                                                                                                                                <br>
                                                                                                                                                <ввод>
                                                                                                                                                    →read
                                                                                                                                                    (
                                                                                                                                                    <список
                                                                                                                                                        переменных>
                                                                                                                                                        )<br>
                                                                                                                                                        <вывод>
                                                                                                                                                            →write
                                                                                                                                                            (
                                                                                                                                                            <список
                                                                                                                                                                переменных>
                                                                                                                                                                )<br>
                                                                                                                                                                <цикл>
                                                                                                                                                                    →for
                                                                                                                                                                    <выражение
                                                                                                                                                                        цикла>
                                                                                                                                                                        to
                                                                                                                                                                        <тело
                                                                                                                                                                            цикла>
                                                                                                                                                                            <br>
                                                                                                                                                                            <выражение
                                                                                                                                                                                цикла>
                                                                                                                                                                                →ид
                                                                                                                                                                                :=
                                                                                                                                                                                <арифметическое
                                                                                                                                                                                    выражение>
                                                                                                                                                                                    do
                                                                                                                                                                                    <арифметическое
                                                                                                                                                                                        выражение>
                                                                                                                                                                                        <br>
                                                                                                                                                                                        <тело
                                                                                                                                                                                            цикла>
                                                                                                                                                                                            →
                                                                                                                                                                                            <оператор>
                                                                                                                                                                                                /begin
                                                                                                                                                                                                <раздел
                                                                                                                                                                                                    операторов>
                                                                                                                                                                                                    <br>
                                                                                                                                                                                                    end
                    </p>
                    <p class="paragraph">
                        Первым шагом при разработке процессора грамматического разбора, основанного на методе
                        операторного предшествования, должно быть установление отношений предшествования между
                        операторами
                    </p>
        </div>
    </div>
    <!--p17-->
    <div class="wrapper">
        <div class="container">
            <p>
                грамматиками. При этом под оператором понимается любой терминальный символ (т.е. любая лексема).
                Таким образом, мы должны, в частности, установить отношения предшествования между лексемами
                begin, read, (. Приведем матрицу, которая задает отношения предшествования для нашей грамматики (табл.
                4).
            </p>
            <p class="paragraph">
                Каждая клетка этой матрицы определяет отношение предшествования (если оно существует) между
                лексемами, соответствующими строке и столбцу, на пересечении которых находится эта клетка. Например, мы
                видим, что
            </p>
            <p class="expressions">
                program = var и<br>
                begin <• read </p>
                    <p class="paragraph">
                        Отношение = означает, что обе лексемы имеют одинаковый уровень предшествования и должны
                        рассматриваться грамматическим процессором в качестве составляющих одной конструкции языка.
                        Обратите внимание, что для отношения предшествования не выполняются некоторые правила, привычные
                        для отношения арифметического порядка. Например,
                    </p>
                    <p class="expressions">
                        ; •> end, но end •> ;
                    </p>
                    <p class="paragraph">Обратите внимание также на то, что для многих пар лексем отношения
                        предшествования не существует. Это означает, что соответствующие пары лексем не могут находиться
                        рядом ни в каком грамматически правильном предложении. Если подобная комбинация лексем все же
                        встретится в процессе
                        грамматического разбора, то она должна рассматриваться как синтаксическая ошибка.</p>
                    <p class="paragraph">Для применимости метода операторного предшествования необходимо, чтобы
                        отношения предшествования были заданы одиозначно, например, не должно быть одновременно
                        отношений ; <• begin и ;>• begin. Это требование выполняется для нашей грамматики, однако,
                            несущественные ее изменения
                            могут привести к тому, что некоторые из отношений перестанут быть однозначными и метод
                            операторного предшествования станет не применимым.</p>
                    <p class="paragraph">Приведем пример разбора с помощью операторного предшествования. Пусть
                        анализируется предложение read из нашей программы. Это предложение анализируется по лексемам
                        слева направо. Для
                        каждой пары соседних операторов определено отношение предшествования</p>
                    <p class="code">
                        begin read ( ид. ) ;<br>
                        <•=<•. •> •><br>
                            begin read ( <N1> ) ;<br>
                                <•==•><br>
                                    begin <N2> ;<br>
                                        <• <br>

                    </p>
                    <p class="paragraph">
                        На первом шаге процесса грамматического разбора выделим фрагмент, ограниченный отношениями <• и
                            •> для распознавания в терминах грамматики. В данном случае этот фрагмент содержит
                            единственную лексему ид. Эта лексема может быть распознана как нетерминал <значение> в
                                соответствии с
                                правилом из грамматики.
                    </p>
                    <table>
                        <caption>Таблица 1</caption>
                        <tr>
                            <th>Лексемы</th>
                            <th>begin</th>
                            <th>end</th>
                            <th>End.</th>
                            <th>Integer</th>
                            <th>for</th>
                            <th>read</th>
                            <th>write</th>
                            <th>to</th>
                            <th>do</th>
                            <th>;</th>
                        </tr>
                        <tr>
                            <td>program</td>
                            <td>=</td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>var</td>
                            <td></td>
                            <td>=</td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>begin</td>
                            <td></td>
                            <td></td>
                            <td>=</td>
                            <td>=</td>
                            <td></td>
                            <td>
                                << /td>
                            <td>
                                << /td>
                            <td>
                                << /td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>end</td>
                            <td></td>
                            <td></td>
                            <td>></td>
                            <td>></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>integer</td>
                            <td></td>
                            <td>></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>for</td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
        </div>
    </div>
    <!--p18-->
    <div class="wrapper">
        <div class="container">
            <table id="table_1">
                <tr>
                    <td>read</td>
                    <td>=</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>write</td>
                    <td></td>
                    <td>=</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td>to</td>
                    <td></td>
                    <td></td>
                    <td>=</td>
                    <td>=</td>
                    <td></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td>do</td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td></td>
                </tr>
                <tr>
                    <td>;</td>
                    <td></td>
                    <td>></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td></td>
                </tr>
                <tr>
                    <td>:</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>:</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>,</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>:=</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>+</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>-</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>*</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>div</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>(</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>)</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>ид</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>конст</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <table id="table_2">
                <caption>Таблица 4</caption>
                <tr>
                    <th>:</th>
                    <th>,</th>
                    <th>:=</th>
                    <th>+</th>
                    <th>-</th>
                    <th>*</th>
                    <th>div</th>
                    <th>(</th>
                    <th>)</th>
                    <th>ид</th>
                    <th>конст</th>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>=</td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>=</td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td>
                        << /td>
                    <td></td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                    <td>=</td>
                    <td>
                        << /td>
                    <td>
                        << /td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td></td>
                    <td>></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>></td>
                    <td>></td>
                    <td>=</td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td></td>
                    <td>></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td>></td>
                    <td></td>
                    <td>></td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
        </div>
    </div>
    <!--p19-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">Однако эта лексема может быть также распознана как нетерминальный символ <список
                    переменных>. Для рассматриваемого метода неважно, какой конкретно нетерминальный символ распознан.
                    Лексема ид интерпретируется просто как некий нетерминальный символ <N1>. Конструкция
                        read(<N1>) интерпретируется как один нетерминальный символ <N2>.</p>
            <p class="paragraph">На этом разбор предложения read закончено. Если мы сравним деревья грамматического
                разбора
                для этого предложения, то увидим, что они полностью совпадают, за исключением имен нетерминальных
                символов.</p>
            <p class="paragraph">Рассмотрим грамматический разбор для оператора</p>
            <p class="code">
                ; rez: = sum div 100 – А * А ;<br>
                <=<>
                    <>
                        <>
                            <><br>
                                ; rez := <N1> div <N2> – <N4> * <N5> ;<br>
                                                <=<>
                                                    <><br>
                                                        ; rez := <N3> – <N6> ;<br>
                                                                <=<><br>
                                                                    ; rez := <N7> ;<br>
                                                                        <=>
            </p>
            <p class="paragraph">При этом дерево грамматического разбора имеет вид, представленный на рис. 9.</p>
            <p class="paragraph">Заметим еще раз, что процесс грамматического разбора начинается слева направо и
                продолжается
                на каждом шаге до тех пор, пока не определится очередной фрагмент предложения для грамматического
                распознавания, т.е. первый фрагмент, ограниченный отношениями <• и •>. Как только подобный
                    фрагмент выделен, он интерпретируется как некоторый очередной нетерминальный символ в соответствии с
                    каким-нибудь правилом грамматики. Этот процесс продолжается до тех пор, пока предложение
                    не будет распознано целиком.</p>
            <img id="image" src="image/image1_page_19.jpg">
            <p class="paragraph">Обратите внимание, что каждый фрагмент дерева грамматического разбора строится, начиная
                с конечных узлов вверх, в сторону корня дерева. Отсюда и возник термин восходящий разбор. Если мы
                рассмотрим дерево грамматического разбора, исходя из грамматики языка (рис. 8), то увидим, что оно
                несколько отличается от полученного методом операторного предшествования дерева (рис. 9).</p>
            <p class="paragraph">Например, идентификатор sum был сначала интерпретирован как <значение>, а потом как
                    <слагаемое>, являющийся одним из операндов операции div. При разборе методом операторного
                        предшествования идентификатор sum был интерпретирован как единственный нетерминал <N1>, который
                            является
                            операндом операции div. Таким образом, <N1> соответствует двум нетерминальным символам
                                <значение> и <слагаемое>. Имеются и другие подобные различия.</p>
            <p class="paragraph">Они вытекают из свободы образования имен нетерминальных символов, распознаваемых в
                рамках
                метода операторного предшествования. Интерпретация sum сначала как <значение>, а потом как <слагаемое>
                        является просто переименованием нетерминальных символов. Такое переименование необхо-</p>
        </div>
    </div>
    <!--p20-->
    <div class="wrapper">
        <div class="container">
            <p>
                димо, поскольку в соответствии с грамматикой (правило 8) первым операндом операции умножения
                должен быть <слагаемое>, а не <значение>. Так как для нашего метода имена нетерминальных символов
                        несущественны, то подобные переименования становятся ненужным. Собственно говоря, три различных
                        имени: <арифметическое выражение>, <слагаемое>, <значение> – были включены в грамматику только
                                    как средства описания отношения предшествования между операторами (например, для
                                    указания того, что умножение следует выполнять после сложения). Поскольку эта
                                    информация содержится
                                    в нашей матрице предшествования, то становится ненужным различать эти три имени в
                                    процессе грамматического разбора.
            </p>
            <p class="paragraph">Возможный алгоритм метода операторного предшествования приведен на рис. 10.</p>
            <p class="paragraph">В данном алгоритме первоначально просматривается цепочка лексем (массив L),
                устанавливается
                отношение предшествования между соседними лексемами по таблице отношений предшествования
                (матрица M[n × n]) до тех пор, пока не встретится отношение '>' (блоки 4–5). После этого возвращаемся
                по массиву лексем назад, пока между лексемами не встретится отношение '<' (блоки 7–8). Затем лексемы,
                    ограниченные отношениями '< >' , записываются во внутреннее представление (блоки 9–10) .</p>
                    <p class="paragraph">В блоках 12 – 14 элементы массива лексем сдвигаются на длину выведенной
                        цепочки. Так продолжается, пока не распознана вся последовательность лексем.</p>
                    <img id="image" src="image/image1_page_20.jpg">
        </div>
    </div>
    <!--p21-->
    <div class="wrapper">
        <div class="container">
            <h2>
                1.3. ВНУТРЕННЕЕ ПРЕДСТАВЛЕНИЕ ПРОГРАММЫ
            </h2>
            <p class="paragraph">
                На выходе синтаксического анализатора формируется программа во внутреннем представлении.
                Существует несколько различных способов представления программы в некоторой промежуточной
                форме для анализа и оптимизации кода: последовательность четверок, последовательность троек, постфиксная
                запись, префиксная запись, синтаксическое дерево.
            </p>
            <h3>
                1.3.1. Последовательность четверок
            </h3>
            <p class="paragraph">
                Каждая четверка записывается в виде
            </p>
            <p class="expressions">
                операция ор1, ор2, результат
            </p>
            <p>
                где операция – выполняемая объектным кодом функция; ор1, ор2 – операнды этой операции; результат
                определяет, куда должно быть помещено результирующее значение.
            </p>
            <p class="paragraph">
                Например, предложение исходной программы (рис. 1): sum: = sum + а может быть представлено
                четверками следующим образом:
            </p>
            <p class="expressions">+ sum , а , I1<br>:= I1 , , sum</p>
            <p class="paragraph">Здесь I1 обозначает промежуточный результат (sum + а), вторая четверка присваивает это
                значение
                переменной sum.</p>
            <p class="paragraph">Все четверки расположены в том порядке, в котором должны выполняться соответствующие
                инструкции объектного кода, что существенно облегчает анализ для оптимизации кода. Это означает также,
                что трансляция в машинные коды будет относительно простой. В табл. 5 представлена последовательность
                четверок, соответствующая исходной программе.</p>
            <p class="paragraph">За операциями геаd и write следует четверка рaram, определяющая параметры операций read
                и write.
                Четверка рaram будет, разумеется, при окончательной генерации машинного кода оттранслирована в
                список параметров. Операция > в четверке 3 сравнивает значение двух своих операндов и осуществляет
                переход к четверке 9, если первый операнд больше второго. Операция goto в четверке 8 осуществляет
                безусловный переход к четверке 3.</p>
            <table>
                <caption>Таблица 5</caption>
                <tr>
                    <th></th>
                    <th>Операция</th>
                    <th>Операнд 1</th>
                    <th>Операнд 2</th>
                    <th>Результат</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td>:=</td>
                    <td>#0</td>
                    <td></td>
                    <td>sum</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>:=</td>
                    <td>#1</td>
                    <td></td>
                    <td>I</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>></td>
                    <td>I</td>
                    <td>#100</td>
                    <td>9)</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>read</td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>5</td>
                    <td>param</td>
                    <td>a</td>
                    <td></td>
                    <td>sum</td>
                </tr>
                <tr>
                    <td>6</td>
                    <td>+</td>
                    <td>sum</td>
                    <td>a</td>
                    <td>I1</td>
                </tr>
                <tr>
                    <td>7</td>
                    <td>:=</td>
                    <td>I1</td>
                    <td></td>
                    <td>sum</td>
                </tr>
                <tr>
                    <td>8</td>
                    <td>goto</td>
                    <td></td>
                    <td></td>
                    <td>3)</td>
                </tr>
                <tr>
                    <td>9</td>
                    <td>div</td>
                    <td>sum</td>
                    <td>#100</td>
                    <td>I1</td>
                </tr>
                <tr>
                    <td>10</td>
                    <td>*</td>
                    <td>a</td>
                    <td>a</td>
                    <td>I3</td>
                </tr>
                <tr>
                    <td>11</td>
                    <td>-</td>
                    <td>I2</td>
                    <td>I3</td>
                    <td>I4</td>
                </tr>
                <tr>
                    <td>12</td>
                    <td>:=</td>
                    <td>I4</td>
                    <td></td>
                    <td>rez</td>
                </tr>
                <tr>
                    <td>13</td>
                    <td>write</td>
                    <td></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>14</td>
                    <td>param</td>
                    <td>rez</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>15</td>
                    <td>param</td>
                    <td>sum</td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
        </div>
    </div>
    <!--p22-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">
                Таким образом, последовательность четверок и является результатом работы синтаксического анализатора.
            </p>
            <h3>
                1.3.2. Постфиксная запись
            </h3>
            <p class="paragraph">
                Обычно программа осуществляет те или иные действия над данными. Соответствующие операции
                программист записывает, используя инфиксную форму записи, в которой знак операции ставится между
                операндами. Например:
            </p>
            <p class="expressions">
                (А + В) * С.
            </p>
            <p class="paragraph">Вычисление такого выражения является непростой задачей. Операцию умножения нельзя
                выполнить до тех пор, пока не будет прочитан второй операнд С. Если этот операнд сам является сложным
                выражением, то прежде, чем выполнить умножение, необходимо считать много данных из текста программы.
                Отмеченные трудности можно легко обойти, если использовать другую форму записи операций.
                Она называется постфиксной и отличается тем, что знак операции ставится непосредственно за операндами.
                Такая запись обладает двумя ценными свойствами, благодаря которым ее используют как промежуточную форму
                представления исходной программы при трансляции:</p>
            <p class="paragraph">1. Для записи любого выражения не нужны скобки. Так как оператор непосредственно
                следует за
                операндами, участвующими в операции, неопределенность в указании операндов отсутствует. Например,
                выражение (А + В) * С в постфиксной записи имеет вид: А В + С *.</p>
            <p class="paragraph">2. К моменту считывания очередного оператора соответствующие операнды уже прочитаны.
                Поэтому оператор может быть выполнен без чтения каких-либо дополнительны данных.</p>
            <p class="paragraph">Сказанное выше относится к бинарным операциям, однако не трудно распространить
                результаты
                рассуждений и на унарные операции. Однако при этом могут возникнуть сложности. Например, знак "–
                " может стоять в инфиксной записи, указывая как бинарную, так и унарную операцию, и его правильный смысл
                становится очевидным из контекста. В постфиксной записи сделать это труднее. Унарный
                минус и другие унарные операции можно представлять двумя способами: либо записывать их как бинарные
                операции, например, вместо " – В " писать " 0 – В "; либо для обозначения унарных операций
                вводить новый символ, например, выражение А + (– В + С * Е) в постфиксной форме примет вид: А В
                @ С Е * + +</p>
            <h2>
                1.4. ГЕНЕРАЦИЯ КОДА
            </h2>
            <p class="paragraph">Возможны три формы объектного кода: абсолютные команды, помещенные в фиксированные
                ячейки (после окончания компиляции такая программа немедленно выполняется); программа на автокоде (ее
                потом придется транслировать); программа на языке машины, записанная на внешнюю память (для выполнения
                она должна быть объединена с другими подпрограммами и затем загружена).</p>
            <p class="paragraph">Первый вариант наиболее экономичен в отношении расходуемого времени. Главный недостаток
                этого варианта состоит в том, что нельзя предварительно и независимо протранслировать несколько
                подпрограмм и затем объединить их вместе дня выполнения, все подпрограммы должны транслироваться
                одновременно. Выигрыш во времени оборачивается проигрышем в гибкости.</p>
            <p class="paragraph">Проще всего получить объектную программу на автокоде. В этом случае не приходится
                формировать команды как последовательности битов; можно порождать команды, содержащие символические
                имена. Более того, можно формировать макроопределение. Это позволяет также уменьшить объем компилятора.
            </p>
            <p class="paragraph">Несмотря на очевидные достоинства, трансляция на автокод обычно считается наихудшим из
                вариантов. И в самом деле, к процессу трансляции добавляется еще один шаг, который часто требует столько
                же времени, сколько длится собственно компиляция.</p>
            <P class="paragraph">Большинство промышленных компиляторов вырабатывают объектную программу в виде
                объектного модуля. Как правило, объектный модуль содержит символические имена других программ
                (подпрограмм), к которым он обращается, и имена своих входных точек, к которым можно обращаться из
                других программ. Эта объектная программа "объединяется" с теми другими объектными программами, а
                затем загружается в некоторую область памяти для выполнения.</p>
        </div>
    </div>
    <!--p23-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">В этом варианте обеспечивается гораздо большая гибкость, и поэтому во многих системах
                он и
                принят в качестве стандартной процедуры. Следует, однако, заметить, что на объединение и загрузку
                также расходуется время.</p>
            <p class="paragraph">Теперь покажем, как генерируются команды для последовательности четверок и постфиксной
                записи, используя в качестве примера выражение</p>
            <p class="expressions">А * ((А * В + С) – С * В).</p>
            <p class="paragraph">
                Будем считать переменные А, В, С, В целыми.
            </p>
            <p class="paragraph">
                Генерация кода для последовательности четверок. Для рассматриваемого примера последовательность четверок
                имеет вид:
            </p>
            <img id="image_1" src="image/image1_page_23.jpg">
            <p class="paragraph">
                В основе процедуры генерации кода лежит оператор саsе:
                ргосеdure ГК; саsе код операции четверки of
            </p>
            <p class="paragraph">
            <p class="paragraph">
                * : подпрограмма, соответствующая операции *;<br>
                + : подпрограмма, соответствующая операции + ;<br>
                – : подпрограмма, соответствующая операции – ;<br>
                end;<br>
                end;</p>
            </p>
            <p class="paragraph">Генерация кода для постфиксной записи. Для рассматриваемого примера постфиксная запись
                имеет вид: A A B * C + C D * – A *. Операторы и операнды просматриваются последовательно слева
                направо. Всякий раз, когда просматривается операнд, в стек заносится его имя. А когда встречается
                операция, генерируются команды для ее выполнения. При этом в качестве описаний операндов используются
                два верхних описания в стеке; затем эти два описания заменяются описанием результата. При
                этом необходимо сформировать временное имя Ti, которое заносится в стек.</p>
            <p class="paragraph">На практике стек можно отобразить на одномерный массив S(1), S(2), …, S(n). Для
                указания вершины стека можно использовать индекс i. При записи в стек указатель вершины будет сдвигаться
                в сторону конца массива, при чтении из стека указатель вершины будет перемещатьсяя в сторону начала
                массива (рис. 11).</p>
            <img id="image_2" src="image/image2_page_23.jpg">
            <p class="paragraph">
                Для обработки доступен только элемент S(i), т.е. вершина стека. Значение i = 0 перед чтением из
                стека служит признаком того, что стек пуст, а значение i = n перед записью в стек признаком того, что
                стек переполнен.
            </p>
        </div>
    </div>
    <!--p24-->
    <div class="wrapper">
        <div class="container">
            <h1>
                2. ОРГАНИЗАЦИЯ ТАБЛИЦ СИМВОЛОВ
            </h1>
            <hr>
            <p class="paragraph">Проверка правильности семантики и генерация кода требуют знания характеристик
                идентификаторов, используемых в программе на исходном языке. Эти характеристики выясняются из описаний и
                из
                того, как идентификаторы используются в программе. Вся информация накапливается в таблицах символов.</p>
            <p class="paragraph">Таблицы всех типов имеют общий вид (табл. 6). В нашем случае аргументами таблицы
                являются
                символы или идентификаторы, а значениями – их характеристики. Когда компилятор начинает трансляцию
                исходной программы, таблица символов пуста или содержит только несколько элементов для служебных слов и
                стандартных функций.</p>
            <p class="paragraph">В процессе компиляции для каждого нового идентификатора элемент добавляется только один
                раз,
                но поиск ведется всякий раз, когда встречается этот идентификатор. Так как на этот процесс уходит
                много времени, важно выбрать такую организацию таблиц, которая допускала бы эффективный поиск.</p>
            <table>
                <caption>Таблица 6</caption>
                <tr>
                    <th>№</th>
                    <th>Аргумент</th>
                    <th>Значение</th>
                </tr>
                <tr>
                    <td>1</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>2</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>N</td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <h2>
                2.1. УПОРЯДОЧЕННЫЕ И НЕУПОРЯДОЧЕННЫЕ ТАБЛИЦЫ
            </h2>
            <p class="paragraph">Простейший способ организации таблицы состоит в том, чтобы добавлять элементы в порядке
                их
                поступления без каких-либо попыток упорядочения. Поиск в этом случае требует сравнения с каждым
                элементом таблицы, пока не будет найден подходящий. Для таблицы, содержащей N элементов, в среднем будет
                выполнено N/2 сравнений. Если N велико, такой способ неэффективен. Поиск может быть
                выполнен более эффективно, если элементы таблицы упорядочены согласно некоторому естественному
                порядку аргументов. В нашем случае, когда аргументами являются строки символов, наиболее естественным
                является упорядочение по алфавиту. Эффективным методом поиска в упорядоченном списке
                является так называемый бинарный поиск. Символ S, который следует найти, сравнивается с аргументом (n +
                1)/2 в середине таблицы. Если этот элемент не является требуемым, мы должны просмотреть
                только блок элементов от (n + 1)/2 + 1 до n или от 1 до (n + 1)/2 – 1 в зависимости от того, больше
                элемент S или меньше элемента, с которым его сравнивали. Затем мы повторяем процесс над блоком
                меньшего размера.</p>
            <p class="paragraph">Так как на каждом шаге число элементов, которые могут содержать S, сокращается
                наполовину,
                максимальное число сравнений равно log2(n + 1). Если n = 2, нам потребуется самое большее 2 сравнения;
                если n = 4 – то 3; если n = 8 – то 4. Для n = 128 бинарный поиск требует самое большее 8 сравнений. В то
                время, как в неупорядоченной таблице в среднем потребуется 64 сравнения.</p>
            <p class="paragraph">Сортировка таблицы производится методом упорядоченных вставок.</p>
            <h2>
                2.2. ХЕШ-АДРЕСАЦИЯ
            </h2>
            <img src="">
            <p class="paragraph">
                Наиболее эффективный и широко применяемый в компиляторах метод при работе с таблицами
                символов – хеш-адресация. Механизм расстановки состоит из таблицы и хеш-функции (табл. 7).
            </p>
        </div>
    </div>
    <!--p25-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">
                Таблица состоит из N элементов, где N заранее фиксировано. Метод хеш-адресации заключается в
                преобразовании символа в индекс элемента в таблице. Индекс получается хешированием символа, т.е.
                выполнением над ним некоторых операций. Если в процессе компиляции встретился объект а, то для
                поиска его в таблице можно воспользоваться следующим алгоритмом: если объект уже встречался
                ранее, то h(а) – ячейка в таблице, в которой хранится а. Если объект а ранее не встречался, то h(а) –
                пустая ячейка, в которую заносится информация для а.
            </p>
            <table>
                <caption>Таблица 7</caption>
                <tr>
                    <th>№</th>
                    <th>Аргумент</th>
                    <th>Значение</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>1</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>h(a)</td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td>...</td>
                    <td>...</td>
                    <td>...</td>
                </tr>
                <tr>
                    <td>N</td>
                    <td></td>
                    <td></td>
                </tr>
            </table>
            <p class="paragraph">
                Возникает, однако, затруднение, если результаты хеширования двух разных символов совпадают.
                Это называется коллизией. Очевидно, в данной позиции таблицы может быть помещен только один из
                этих символов, так что мы должны найти свободное место для второго. Желательно иметь такую хешфункцию,
                которая распределяла бы объекты равномерно по всей таблице, так чтобы коллизии не возникали слишком
                часто. Но избежать их совсем практически не удается, поэтому разработчику компилятора следует
                предусмотреть способы решения задачи коллизии. Существует два таких способа – рехеширование и метод
                цепочек.
            </p>
            <p class="paragraph">
                Для простоты предположим, что каждый табличный элемент занимает одно слово. Тогда для таблицы с n
                элементами значениями функции хеширования h являются целые числа 0, 1, 2, …, n – 1. Если
                табличный элемент состоит из k слов, то для вычисления его адреса, необходимо к базовому адресу
                таблицы добавить произведение значения хеш-функции h на k.
            </p>
            <h2>2.3. РЕХЕШИРОВАНИЕ</h2>
            <p class="paragraph">
                Предположим, что мы хешируем символ S и обнаруживаем, что другой символ уже занял элемент с
                номером h. Возникает коллизия. Тогда сравниваем S c элементом в ячейке h + p<sub>1</sub> (для некоторого
                целого
                p<sub>1</sub>). Если снова возникает коллизия, сравниваем S с элементом h + p<sub>2</sub>. Это
                продолжается до тех пор, пока
                не встретится ячейка h + p<sub>i</sub>, которая либо пуста, либо содержит S, либо совпадает с ячейкой h
                (p<sub>i</sub> = 0). В
                последнем случае считаем, что таблица переполнена
            </p>
            <p class="paragraph">
                Таким образом, если возникло i коллизий, будет выполнено i + 1 сравнение с элементами таблицы.
                Элементы p<sub>i</sub> должны выбираться так, чтобы ожидаемое число сравнений было невелико, но при этом
                рассматривалось большее число элементов. В идеальном случае p<sub>i</sub> должны охватывать целые числа
                0, 1,
                …, n – 1.
            </p>
            <p class="paragraph">
                Существуют несколько способов рехеширования. Рассмотрим некоторые из них.
            </p>
            <h3>2.3.1. Линейное рехеширование</h3>
            <p class="paragraph">
                Это простейший метод рехеширования, состоящий в том, чтобы принять p<sub>1</sub> = 1, p<sub>2</sub> = 2,
                p<sub>3</sub> = 3 и так
                далее. В этом случае мы двигаемся по таблице вперед относительно значения h(a) до тех пор, пока не
                исчезнет коллизия. Если достигнута позиция n – 1, переходим на позицию 0. Метод прост для выполнения,
                однако, если уже возник конфликт, то занятые позиции имеют тенденцию скапливаться. Метод выражается
                формулой
            </p>
            <p class="expressions">
                <i>h<sub>i</sub>(a) = (h(a) + i)</i> mod<i> n,</i> 1 ≤ <i>i ≤ n </i>−1
            </p>
        </div>
    </div>
    <!--p26-->
    <div class="wrapper">
        <div class="container">
            <h3>2.3.2. Случайное рехеширование</h3>
            <p class="paragraph">
                Этот метод снимает проблему скопления, которая свойственна линейному рехешированию, за счет
                выбора в качестве <i>p<sub>i</sub></i> достаточно использовать самый элементарный генератор случайных
                чисел, выдающий все числа в интервале от 0 до <i>n</i> – 1 по одному разу. Каждый раз, когда
                используется генератор
                случайных чисел, он устанавливается в одно и то же состояние. Таким образом, когда происходит обращение
                к <i>h</i>, генерируется одна и та же последовательность <i>p<sub>1</sub>, p<sub>2</sub></i>, … .
            </p>
            <h3>2.3.3. Рехеширование сложением</h3>
            <p class="paragraph">
                В этом случае принимаем <i>p<sub>i</sub> = i * h</i>, где <i>h</i> – исходный хеш-индекс. Таким образом
                рассматриваются
                элементы таблицы с номерами <i>h</i>, <i>2h</i>, <i>3h</i>, <i>4h</i> … . Этот метод хорош, если
                размерность таблицы <i>n</i> будет
                простым числом, то все последовательности полностью покроют все возможные индексы 1, …, <i>n</i> – 1.
                Метод описывается формулой:
            </p>
            <p class="expressions">
                <i>h<sub>i</sub>(a) = (ih(a)) </i>mod <i>n, </i>1 ≤ <i>i</i> ≤ <i>n</i> −1 .
            </p>
            <h2>2.4. МЕТОД ЦЕПОЧЕК</h2>
            <p class="paragraph">
                Метод цепочек использует хеш-таблицу, элементы которой первоначально равны 0, собственно
                таблицу символов, вначале пустую, и указатель УК, который указывает на текущее положение последнего
                элемента в таблице символов. Элементы таблицы символов имеют дополнительное поле СНАIN,
                которое может содержать 0 или адрес другого элемента таблицы символов. Начальное состояние таблицы
                приведено на рис. 12.
            </p>
            <p class="paragraph">
                Хеш-функция, примененная к символу, дает индекс указателя в хеш-таблице. Указатель либо равен
                0, либо указывает на первый элемент таблицы символов с данным значением хеш-функции. Поле
                СНАIN каждого элемента используется для того, чтобы связать в цепочку элементы, для которых хеширование
                символа приводит к тому же самому указателю. Например, в таблицу необходимо записать
                символ S1. Функция хеширования вырабатывает адрес элемента хеш-таблицы, например 4. Содержимое
                этой ячейки равно 0. Тогда выполняется следующее:
            </p>
            <li class="decimal">Прибавляем 1 к УК.</li>
            <li class="decimal">Вносим элемент (S1, значение, 0) в позицию таблицы символов, на которую указывает УК.
            </li>
            <li class="decimal">Заносим содержимое УК в указатель 4 хеш-таблицы</li>
            <!--<img src="image/image1_page_26.jpg" style="width: 60%;">-->

            <div class="two_tables">
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Хеш-таблица</th>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>...</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>N - 1</td>
                            <td></td>
                        </tr>
                    </table>
                </div>
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Аргумент</th>
                            <th>Значение</th>
                            <th>CHAIN</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>...</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>N</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </div>
                <div class="vert_span_div"><span class="vert_span">УК=0</span></div>
            </div>
            <p class='picture_number'>
                Рис.12
            </p>
            <div class="two_tables">
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Хеш-таблица</th>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>4</td>
                        </tr>
                    </table>
                </div>
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Аргумент</th>
                            <th>Значение</th>
                            <th>CHAIN</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>S1</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>S2</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>S3</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>S4</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </div>
                <div class="vert_span_div"><span class="vert_span">УК=4</span></div>
            </div>
            <p class='picture_number'>
                Рис.13
            </p>
        </div>
    </div>
    <!--p27-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">
                Пока поступают символы, хеширование которых дает индексы разных указателей, они заносятся в
                таблицу аналогичным образом. Так, если мы записываем в таблицу символы <i>S2</i>, <i>S3</i>, <i>S4</i>,
                хеширование которых
                дает ссылки на указатели 1, 3, 6, таблица примет вид, представленный на рис. 13.
            </p>
            <p class="paragraph">
                В конце концов, поступит символ <i>S5</i>, который ссылается на указатель, использовавшийся ранее,
                например на 6. Вот здесь и начинает действовать поле CHAIN. Символ <i>S5</i> записывается в таблицу
                символов и добавляется к концу цепочки для этого указателя (рис. 14).
            </p>
            <div class="two_tables">
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Хеш-таблица</th>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>4</td>
                        </tr>
                    </table>
                </div>
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Аргумент</th>
                            <th>Значение</th>
                            <th>CHAIN</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>S1</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>S2</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>S3</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>S4</td>
                            <td>...</td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>S5</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>&nbsp;</td>
                            <td></td>
                            <td></td>
                            <td></td>
                        </tr>
                    </table>
                </div>
                <div class="vert_span_div"><span class="vert_span">УК=5</span></div>
            </div>
            <p class='picture_number'>
                Рис.14
            </p>
            <p class="paragraph">
                На рис. 15 приведена блок-схема алгоритма занесения одного элемента <i>S</i> в таблицу символов с
                помощью метода цепочек
            </p>
            <p class="paragraph">
                Пусть необходимо внести в таблицу символы <i>S6</i>, <i>S7</i>, <i>S8</i>, которые ссылаются на
                указатели 4, 3, 3, соответственно (рис. 16).
            </p>
            <img src="image/image1_page_27.jpg" style="width: 50%;">
        </div>
    </div>
    <!--p28-->
    <div class="wrapper">
        <div class="container">
            <div class="two_tables">
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Хеш-таблица</th>
                        </tr>
                        <tr>
                            <td>0</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>2</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>3</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>1</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td></td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>4</td>
                        </tr>
                    </table>
                </div>
                <div>
                    <table>
                        <tr>
                            <th>№</th>
                            <th>Аргумент</th>
                            <th>Значение</th>
                            <th>CHAIN</th>
                        </tr>
                        <tr>
                            <td>1</td>
                            <td>S1</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>2</td>
                            <td>S2</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>3</td>
                            <td>S3</td>
                            <td>...</td>
                            <td>7</td>
                        </tr>
                        <tr>
                            <td>4</td>
                            <td>S4</td>
                            <td>...</td>
                            <td>5</td>
                        </tr>
                        <tr>
                            <td>5</td>
                            <td>S5</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>6</td>
                            <td>S6</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                        <tr>
                            <td>7</td>
                            <td>S7</td>
                            <td>...</td>
                            <td>8</td>
                        </tr>
                        <tr>
                            <td>8</td>
                            <td>S8</td>
                            <td>...</td>
                            <td>0</td>
                        </tr>
                    </table>
                </div>
                <div class="vert_span_div"><span class="vert_span">УК=8</span></div>
            </div>
            <p class='picture_number'>
                Рис.16
            </p>
        </div>
    </div>
    <!--p29-->
    <div class="wrapper">
        <div class="container">
            <h1>
                3. ОПТИМИЗАЦИЯ КОДА
            </h1>
            <hr>
            <p class="paragraph">
                Рассмотрим некоторые методы машинно-независимой оптимизации кода. Мы не будем стремиться
                к детальному описанию какого-либо из этих методов. Вместо этого мы дадим словесное описание и
                проиллюстрируем основные понятия примерами.
            </p>
            <p class="paragraph">
                Одним из важных источников оптимизации кода является удаление <i>общих подвыражений</i>, которые
                встречаются в нескольких местах программы и вычисляют одно и тоже выражение. Рассмотрим, например
                предложение:
            </p>
            <p class="code">
                VAR x,y: ARRAY [1..10,1..10] OF INTEGER;<br>
                …<br>
                FOR i : = 1 TO 10 DO<br>
                x [ i , 2*j–1 ] : = y [ i , 2*j ];<br>
                <br>
                …
                <br>
            </p>
            <p class="paragraph">
                Выражение 2*j является общим подвыражением. Оптимизирующий компилятор должен только
                один раз сгенерировать код, вычисляющий это умножение, и использовать его результат в обоих местах.
            </p>
            <p class="paragraph">
                Общие подвыражения обычно обнаруживаются при анализе промежуточной формы представления
                программы (рис. 17). Следует отметить, что в первоначальном варианте требуется выполнить 161 операцию.
            </p>
            <p class="paragraph">
                Если мы исследуем эту последовательность четверок, то обнаружим, что четверки 5 и 11 совпадают, за
                исключением имени получаемого промежуточного результата. Обратите внимание, что операнд j
                не меняет своего значения между четверками 5 и 11. Невозможно достичь четверки 11, не проходя
                предварительно четверку 5, поскольку они расположены на одном линейном участке.
            </p>
            <table align="center" style="margin-top: 5px; width: auto;">
                <tr>
                    <td width="20px">1)</td>
                    <td width="30px">: =</td>
                    <td width="25px">#1</td>
                    <td width="25px"></td>
                    <td width="25px">i</td>
                    <td width="75px">инициализация цикла</td>
                </tr>
                <tr>
                    <td>2)</td>
                    <td>></td>
                    <td>i</td>
                    <td>#10</td>
                    <td>(19)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>3)</td>
                    <td>-</td>
                    <td>i</td>
                    <td>#1</td>
                    <td>i1</td>
                    <td>вычисление индексов для х</td>
                </tr>
                <tr>
                    <td>4)</td>
                    <td>*</td>
                    <td>i1</td>
                    <td>#10</td>
                    <td>i2</td>
                    <td></td>
                </tr>
                <tr>
                    <td>5)</td>
                    <td>*</td>
                    <td>#2</td>
                    <td>j</td>
                    <td>i3</td>
                    <td></td>
                </tr>
                <tr>
                    <td>6)</td>
                    <td>-</td>
                    <td>i3</td>
                    <td>#1</td>
                    <td>i4</td>
                    <td></td>
                </tr>
                <tr>
                    <td>7)</td>
                    <td>-</td>
                    <td>i4</td>
                    <td>#1</td>
                    <td>i5</td>
                    <td></td>
                </tr>
                <tr>
                    <td>8)</td>
                    <td>+</td>
                    <td>i2</td>
                    <td>i5</td>
                    <td>i6</td>
                    <td></td>
                </tr>
                <tr>
                    <td>9)</td>
                    <td>-</td>
                    <td>i</td>
                    <td>#1</td>
                    <td>i8</td>
                    <td>вычисление индексов для y</td>
                </tr>
                <tr>
                    <td>10)</td>
                    <td>*</td>
                    <td>i8</td>
                    <td>#10</td>
                    <td>i9</td>
                    <td></td>
                </tr>
                <tr>
                    <td>11)</td>
                    <td>*</td>
                    <td>#2</td>
                    <td>j</td>
                    <td>i10</td>
                    <td></td>
                </tr>
                <tr>
                    <td>12)</td>
                    <td>-</td>
                    <td>i10</td>
                    <td>#1</td>
                    <td>i11</td>
                    <td></td>
                </tr>
                <tr>
                    <td>13)</td>
                    <td>+</td>
                    <td>i9</td>
                    <td>i11</td>
                    <td>i12</td>
                    <td></td>
                </tr>
                <tr>
                    <td>14)</td>
                    <td>: =</td>
                    <td>y[i12]</td>
                    <td></td>
                    <td>x[i6]</td>
                    <td>операция присваивания</td>
                </tr>
            </table>
        </div>
    </div>
    <!--p30-->
    <div class="wrapper">
        <div class="container">
            <table align="center" style="margin-top: 5px; width: auto;">
                <tr>
                    <td width="20px">15)</td>
                    <td width="30px">+</td>
                    <td width="25px">#1</td>
                    <td width="25px">i</td>
                    <td width="25px">i14</td>
                    <td width="75px">конец цикла</td>
                </tr>
                <tr>
                    <td>16)</td>
                    <td>: =</td>
                    <td>i14</td>
                    <td></td>
                    <td>i</td>
                    <td></td>
                </tr>
                <tr>
                    <td>17)</td>
                    <td>GOTO</td>
                    <td></td>
                    <td></td>
                    <td>(2)</td>
                    <td>следующая операция</td>
                </tr>
                <tr>
                    <td>3)</td>
                    <td>-</td>
                    <td>i</td>
                    <td>#1</td>
                    <td>i1</td>
                    <td>вычисление индексов для х</td>
                </tr>
            </table>
            <p class='picture_number'>
                Рис. 17
            </p>
            <p class="paragraph">
                Таким образом, четверки 5 и 11 вычисляют одно и то же значение. Это означает, что мы можем
                удалить четверку 11 и заменить любые обращения к ее результату (i9) на обращение к переменной i3,
                которая является результатом четверки 5. Эта модификация позволяет избежать дублирования вычислений
                подвыражения 2*j, которое мы выделили как общее подвыражение при анализе исходной программы.
            </p>
            <p class="paragraph">
                После замены i3 на i10 мы обнаружим, что четверки 6 и 12 также совпадают, за исключением имени
                результата. Следовательно, мы можем удалить четверку 12 и заменить переменную i11 всюду, где она
                используется, на переменную i4. Аналогично четверки 10 и 11 также могут быть удалены, поскольку
                они эквивалентны четверкам 3 и 4. В результате получим новую последовательность четверок (рис. 18),
                которая предполагает выполнение всего 121 операции.
            </p>
            <p class="paragraph">
                Обратите внимание, что общее количество четверок сокращено с 17 до 13. Поскольку операции во
                всех используемых здесь четверках займут, вероятно, примерно одинаковое время на обычном компьютере, то
                мы также сократим общее время выполнения программы.
            </p>
            <p class="paragraph">
                Другим источником оптимизации кода является удаление инвариантов цикла. Так называются
                подвыражения внутри цикла, результирующие значения которых не изменяются внутри цикла при переходе от
                одной итерации к другой. Таким образом, эти значения могут быть вычислены только один
                раз перед входом в тело цикла вместо того, чтобы вычислять их заново перед каждой итерацией. Поскольку
                для большинства программ основное время работы приходится на выполнение циклов, экономия времени от
                подобной оптимизации может быть весьма существенной.
            </p>
            <table align="center" style="margin-top: 5px; width: auto;">
                <tr>
                    <td>1)</td>
                    <td>: =</td>
                    <td>#1</td>
                    <td></td>
                    <td>i</td>
                    <td>инициализация цикла</td>
                </tr>
                <tr>
                    <td>2)</td>
                    <td>></td>
                    <td>i</td>
                    <td>#10</td>
                    <td>(14)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>3)</td>
                    <td>-</td>
                    <td>i</td>
                    <td>#1</td>
                    <td>i1</td>
                    <td>вычисление индексов для х</td>
                </tr>
                <tr>
                    <td>4)</td>
                    <td>*</td>
                    <td>i1</td>
                    <td>#10</td>
                    <td>i2</td>
                    <td></td>
                </tr>
                <tr>
                    <td>5)</td>
                    <td>*</td>
                    <td>#2</td>
                    <td>j</td>
                    <td>i3</td>
                    <td></td>
                </tr>
                <tr>
                    <td>6)</td>
                    <td>-</td>
                    <td>i3</td>
                    <td>#1</td>
                    <td>i4</td>
                    <td></td>
                </tr>
                <tr>
                    <td>7)</td>
                    <td>-</td>
                    <td>i4</td>
                    <td>#1</td>
                    <td>i5</td>
                    <td></td>
                </tr>
                <tr>
                    <td>8)</td>
                    <td>+</td>
                    <td>i2</td>
                    <td>i5</td>
                    <td>i6</td>
                    <td></td>
                </tr>
                <tr>
                    <td>9)</td>
                    <td>+</td>
                    <td>i2</td>
                    <td>i4</td>
                    <td>i12</td>
                    <td>вычисление индексов для y</td>
                </tr>
                <tr>
                    <td>10)</td>
                    <td>: =</td>
                    <td>y[i12]</td>
                    <td></td>
                    <td>y[i6]</td>
                    <td>операция присваивания</td>
                </tr>
                <tr>
                    <td>11)</td>
                    <td>+</td>
                    <td>#1</td>
                    <td>i</td>
                    <td>i14</td>
                    <td>конец цикла</td>
                </tr>
                <tr>
                    <td>12)</td>
                    <td>: =</td>
                    <td>i14</td>
                    <td></td>
                    <td>i</td>
                    <td></td>
                </tr>
                <tr>
                    <td>13)</td>
                    <td>GOTO</td>
                    <td></td>
                    <td></td>
                    <td>(2)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>14)</td>
                    <td>...</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>следующая операция</td>
                </tr>
            </table>
        </div>
    </div>
    <!--p31-->
    <div class="wrapper">
        <div class="container">
            <p class="paragraph">
                Примером инварианта цикла является вычисление выражения 2*j. Результат вычисления этого выражения
                зависит только от операнда j, значение которого не изменяется во время выполнения цикла.
                Таким образом, мы можем поместить четверку 5 непосредственно перед началом выполнения цикла.
                Аналогичные соображения – относительно четверок 6 и 7.
            </p>
            <table align="center" style="margin-top: 5px; width: auto;">
                <tr>
                    <td>1)</td>
                    <td>*</td>
                    <td>#2</td>
                    <td>j</td>
                    <td>i3</td>
                    <td>вычисление инвариантов</td>
                </tr>
                <tr>
                    <td>2)</td>
                    <td>-</td>
                    <td>i3</td>
                    <td>#1</td>
                    <td>i4</td>
                    <td></td>
                </tr>
                <tr>
                    <td>3)</td>
                    <td>-</td>
                    <td>i4</td>
                    <td>#1</td>
                    <td>i5</td>
                    <td></td>
                </tr>
                <tr>
                    <td>4)</td>
                    <td>: =</td>
                    <td>#1</td>
                    <td></td>
                    <td>i</td>
                    <td>инициализация цикла</td>
                </tr>
                <tr>
                    <td>5)</td>
                    <td>></td>
                    <td>i</td>
                    <td>#10</td>
                    <td>(14)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>6)</td>
                    <td>-</td>
                    <td>i</td>
                    <td>#1</td>
                    <td>i1</td>
                    <td>вычисление индексов для х</td>
                </tr>
                <tr>
                    <td>7)</td>
                    <td>*</td>
                    <td>i1</td>
                    <td>#10</td>
                    <td>i2</td>
                    <td></td>
                </tr>
                <tr>
                    <td>8)</td>
                    <td>+</td>
                    <td>i2</td>
                    <td>i5</td>
                    <td>i6</td>
                    <td></td>
                </tr>
                <tr>
                    <td>9)</td>
                    <td>+</td>
                    <td>i2</td>
                    <td>i4</td>
                    <td>i12</td>
                    <td>вычисление индексов для y </td>
                </tr>
                <tr>
                    <td>10)</td>
                    <td>: =</td>
                    <td>y[i12]</td>
                    <td></td>
                    <td>x[i6]</td>
                    <td>операция присваивания</td>
                </tr>
                <tr>
                    <td>11)</td>
                    <td>+</td>
                    <td>#1</td>
                    <td>i</td>
                    <td>i14</td>
                    <td>конец цикла</td>
                </tr>
                <tr>
                    <td>12)</td>
                    <td>: =</td>
                    <td>i14</td>
                    <td></td>
                    <td>i</td>
                    <td></td>
                </tr>
                <tr>
                    <td>13)</td>
                    <td>GOTO</td>
                    <td></td>
                    <td></td>
                    <td>(5)</td>
                    <td></td>
                </tr>
                <tr>
                    <td>14)</td>
                    <td>...</td>
                    <td></td>
                    <td></td>
                    <td></td>
                    <td>следующая операция</td>
                </tr>
            </table>
            <p class='picture_number'>
                Рис. 19
            </p>
            <p class="paragraph">
                <i>Примечание</i>: необходимо выполнить 94 операции.
            </p>
            <p class="paragraph">
                В результате получим новую последовательность четверок (рис. 19). Общее количество четверок
                остается тем же, но количество четверок в цикле уменьшилось с 12 до 9. Каждое выполнение предложения FOR
                вызывает десятикратное повторение тела цикла. Это означает, что общее количество операций, необходимых
                для выполнения FOR, сократилось со 121 до 94.
            </p>
            <p class="paragraph">
                Общее количество операций, приходящееся на одно выполнение предложения FOR, по сравнению с
                начальным вариантом, сократилось со 161 до 94, что существенно уменьшило выполнение программы.
            </p>
            <p class="paragraph">
                Существуют также и более тонкие методы обработки общих подвыражений и инвариантов цикла,
                чем описанные выше. Можно ожидать, что благодаря этим методам может быть получен еще более
                оптимизированный вариант кода.
            </p>
        </div>
    </div>
    <!--p32-->
    <div class="wrapper">
        <div class="container">
            <h1>
                КОНТРОЛЬНЫЕ ВОПРОСЫ И ЗАДАНИЯ
            </h1>
            <hr>
            <li class="decimal">Какова роль лексического анализатора?</li>
            <li class="decimal">Что такое лексемы?</li>
            <li class="decimal">Для чего нужна кодировочная таблица?</li>
            <li class="decimal">Для чего служит таблица символов?</li>
            <li class="decimal">Как организуется таблица символов?</li>
            <li class="decimal">В чем состоит метод бинарного поиска?</li>
            <li class="decimal">Что такое хеширование?</li>
            <li class="decimal">Как работает метод цепочек?</li>
            <li class="decimal">Какие известны способы рехеширования?</li>
            <li class="decimal">Чем отличаются способы нисходящего и восходящего грамматического разбора?</li>
            <li class="decimal">Какие известны методы синтаксического анализа?</li>
            <li class="decimal">В чем сущность метода рекурсивного спуска?</li>
            <li class="decimal">Для чего применяется измененный способ записи БНФ?</li>
            <li class="decimal">В каком виде представляется программа на выходе синтаксического анализатора?</li>
            <li class="decimal">В чем сущность метода операторного предшествования?</li>
            <li class="decimal">Как сравниваются известные способы организации таблиц символов?</li>
            <li class="decimal">В чем суть методов бинарного поиска и упорядоченных вставок?</li>
            <li class="decimal">Каковы достоинства хеш-адресации, и каковы ее недостатки?</li>
            <li class="decimal">Какие известны способы рехеширования?</li>
            <li class="decimal">В чем преимущество метода цепочек по сравнению с рехешированием?</li>
            <li class="decimal">Какая информация хранится в таблице символов?</li>
            <li class="decimal">Как записать информацию о переменных?</li>
            <li class="decimal">Разработать грамматику языка и алгоритмы отдельных этапов трансляции для фрагментов
                программ, приведенным в табл. 8.</li>
            <table class="start" align="center" style="width:auto;">
                <caption>Таблица 8</caption>
                <tr>
                    <td>1. ACCEPT *; A<br>
                        if (A.LE.0) S=S+A<br>
                        S=A*100–K</td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td></td>
                    <td></td>
                </tr>
            </table>
        </div>
    </div>
    <!--p33-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p34-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p35-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p36-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p37-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p38-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p39-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p40-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p41-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p42-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p43-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p44-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p45-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p46-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>

    <!--p47-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p11-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p11-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p11-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p11-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <!--p11-->
    <div class="wrapper">
        <div class="container">
        </div>
    </div>
    <div class="navigation">
        <button class="back">Назад</button>
        <button class="next">Далее</button>
    </div>
    <script src="js/jquery-3.5.1.min.js" defer></script>
    <script src="js/main.js" defer></script>
</body>

</html>